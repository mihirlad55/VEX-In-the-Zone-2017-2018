#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    potentiometerMoGoLift, sensorPotentiometer)
#pragma config(Sensor, in3,    potentiometerArm, sensorPotentiometer)
#pragma config(Sensor, in2,    secondaryBattery, sensorAnalog)
#pragma config(Sensor, in5,    potentiometerMini4Bar, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  limitSwitchArm2, sensorTouch)
#pragma config(Sensor, dgtl4,  encoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  encoderDriveRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  limitSwitchArm1, sensorTouch)
#pragma config(Sensor, dgtl12, LED,            sensorLEDtoVCC)
#pragma config(Motor,  port10,           motorMini4Bar, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port2,           motorArmLeft,  tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           motorArmRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motorMoGoLiftRight, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           motorMoGoLiftLeft, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           motorDriveLeftFront, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           motorDriveLeftBack, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           motorDriveRightFront, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           motorDriveRightBack, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port1,          motorGoliath, tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!IMPORTANT -> Comment out this line to disable competition mode
//#define competitionEnabled


/* Some constant definitions used in the code */

/* These definitions put a name behind the IDs that each LCD button represents */
#define isLCDEnabled					true
#define LCDLeftButton					1
#define LCDCenterButton					2
#define LCDRightButton					4

//#define ENCODER_SCROLL_WHEEL_THRESHOLD	50
//#define ENCODER_SCROLL_WHEEL_MULTIPLIER	1

#define COLOR_BLUE	false
#define COLOR_RED	true
#define SIDE_LEFT	false
#define SIDE_RIGHT	true

#define IS_DRIVE_ENABLED			true
#define IS_PID_ENABLED				false
#define IS_CONTROL_LOCK_ENABLED		false

#define BTN_JOY_LCD_SELECT				Btn8D
#define BTN_JOY_LCD_PREVIOUS			Btn8L
#define BTN_JOY_LCD_NEXT				Btn8R

#define BTN_CONTROL_LOCK_1				Btn8U
#define BTN_CONTROL_LOCK_2				Btn7U
#define BTN_SENSOR_OVERRIDE				Btn7U


#define BTN_GOLIATH_REVERSE				Btn6U

#define BTN_ARM_HIGH_GOAL_PID     		Btn8L

#define BTN_MOGO_LIFT_TOGGLE_AUTO		Btn6D
#define BTN_MOGO_LIFT_EXTEND_MANUAL		Btn6D
#define BTN_MOGO_LIFT_RETRACT_MANUAL	Btn5D

#define BTN_MINI_4_BAR_TOGGLE_AUTO		Btn8D
#define BTN_MINI_4_BAR_EXTEND_MANUAL	Btn8D
#define BTN_MINI_4_BAR_RETRACT_MANUAL	Btn8R

#define BTN_READY_ARM_MACRO				Btn6U



#define JOY_DRIVE_X		Ch1
#define JOY_DRIVE_Y		Ch2
#define JOY_ARM			Ch3
#define JOY_CLAW		Ch4

#define DRIVE_JOYSTICK_DEADZONE	20
#define ARM_JOYSTICK_DEADZONE	20
#define CLAW_JOYSTICK_DEADZONE	20

#define IS_ARM_ENABLED						true
#define ARM_POTENTIOMETER_MIN_VALUE			1200
#define ARM_POTENTIOMETER_MAX_VALUE			2900
#define ARM_POTENTIOMETER_HIGH_GOAL_VALUE	1750
#define ARM_POTENTIOMETER_CONE_HEIGHT_VALUE 400
#define ARM_POTENTIOMETER_CONE_DIFFERENCE	200
#define ARM_POTENTIOMETER_OFFSET			0
#define ARM_POTENTIOMETER_MULTIPLIER 		1

#define IS_MOGO_LIFT_ENABLED					true
#define MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE	1000
#define MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE	2000
#define	MOGO_LIFT_POTENTIOMETER_OFFSET 			0
#define MOGO_LIFT_POTENTIOMETER_MULTIPLIER		1

#define IS_MINI_4_BAR_ENABLED						true
#define MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE 	2000
#define MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE 	1000
#define MINI_4_BAR_POTENTIOMETER_OFFSET				0
#define MINI_4_BAR_POTENTIOMETER_MULTIPLIER 		1

#define IS_GOLIATH_ENABLED		true
#define GOLIATH_INTAKE_POWER	50
#define GOLIATH_REST_POWER		15
#define GOLIATH_OUTTAKE_POWER	-50


#define IS_SLEW_RATE_ENABLED	true
#define MAX_SPEED_DIFFERENCE	20
#define SLEW_RATE				0.15

#define GYRO_MULTIPLIER	1

#define PASSWORD_ENABLED 	false


/* For motor checker */
#define testDuration	2000			// Amount of time to power motors during autocheck
#define motorPower		-127			// Amount of power to give motors during autocheck
#define encoderErrorBounds			0	// Amount encoder should change to indicate a working motor
#define potentiometerErrorBounds	7	// Amount a potentiometer should change to indicate a working motor

#define SCREEN_LIST_MAIN_LENGTH		7
#define SCREEN_LIST_AUTON_LENGTH 	7
#define SCREEN_LIST_SIDES_LENGTH 	3
#define SCREEN_LIST_COLORS_LENGTH	3
#define SCREEN_LIST_PID_LENGTH		7

enum Action { A_DRIVE, A_ARM, A_GOLIATH, A_MINI_4_BAR, A_MOGO_LIFT };
enum State { STATE_EXTENDED, STATE_RETRACTED };
enum WaitForAction { WAIT, WAIT_NONE };

struct MenuItem {
	short id;
	short idx;
	string name;
	string LCDAction;
	bool isDirectional;
};


//main screen menu items
MenuItem menuItemUserControl, menuItemPIDMode, menuItemSwitchCompetitionMode, menuItemGoToAuton, menuItemResetGyro, menuItemBatteryLevel, menuItemCurrentProgram;
//autonomous menu items
MenuItem menuItemAutonGoBack, menuItemAuton15P, menuItemAuton10P, menuItemAuton5P, menuItemAuton15PRT, menuItemAutonNone, menuItemProgSkills1;
//side menu items
MenuItem menuItemSideGoBack, menuItemSideLeft, menuItemSideRight;
//color menu items
MenuItem menuItemColorGoBack, menuItemColorBlue, menuItemColorRed;
//pid menu items
MenuItem menuItemPIDGoBack, menuItemPIDDrive, menuItemPIDGyro, menuItemPIDArm, menuItemPIDMini4Bar, menuItemPIDMoGoLift, menuItemPIDCustom;

//screen lists for LCD
MenuItem* screenListMain[SCREEN_LIST_MAIN_LENGTH];
MenuItem* screenListAuton[SCREEN_LIST_AUTON_LENGTH];
MenuItem* screenListSides[SCREEN_LIST_SIDES_LENGTH];
MenuItem* screenListColors[SCREEN_LIST_COLORS_LENGTH];
MenuItem* screenListPID[SCREEN_LIST_PID_LENGTH];

MenuItem* currentMenu;

MenuItem *startupLCDProgram = &menuItemUserControl;

/* add all the menuItems to their respective lists by reference
and assign ids and indices to each item */
void populateMenuItems() {
	short i = 0;
	short id = 0;

	menuItemUserControl.name = "User Control";
	menuItemUserControl.LCDAction = "<     Start    >";
	menuItemUserControl.idx = i;
	menuItemUserControl.id = id;
	screenListMain[i] = &menuItemUserControl;

	menuItemPIDMode.name = "PID Mode";
	menuItemPIDMode.id = ++id;
	menuItemPIDMode.idx = ++i;
	menuItemPIDMode.LCDAction = "<     Start    >";
	screenListMain[i] = &menuItemPIDMode;

	menuItemSwitchCompetitionMode.name = "Switch Comp. Mode";
	menuItemSwitchCompetitionMode.id = ++id;
	menuItemSwitchCompetitionMode.idx = ++i;
	menuItemSwitchCompetitionMode.LCDAction = "<    Select    >";
	screenListMain[i] = &menuItemSwitchCompetitionMode;

	menuItemGoToAuton.name = "Go To Autonomous";
	menuItemGoToAuton.id = ++id;
	menuItemGoToAuton.idx = ++i;
	menuItemGoToAuton.LCDAction = "<    Select    >";
	screenListMain[i] = &menuItemGoToAuton;


	menuItemResetGyro.name = "Reset Gyro";
	menuItemResetGyro.id = ++id;
	menuItemResetGyro.idx = ++i;
	menuItemResetGyro.LCDAction = "<     Reset    >";
	screenListMain[i] = &menuItemResetGyro;


	menuItemBatteryLevel.name = "Battery Level";
	menuItemBatteryLevel.id = ++id;
	menuItemBatteryLevel.idx = ++i;
	menuItemBatteryLevel.LCDAction = "<    Select    >";
	screenListMain[i] = &menuItemBatteryLevel;

	menuItemCurrentProgram.name = "Current Program";
	menuItemCurrentProgram.id = ++id;
	menuItemCurrentProgram.idx = ++i;
	screenListMain[i] = &menuItemCurrentProgram;

	i = 0;

	menuItemAutonGoBack.name = "Go Back";
	menuItemAutonGoBack.id = ++id;
	menuItemAutonGoBack.idx = i;
	menuItemAutonGoBack.LCDAction = "<    Select    >";
	screenListAuton[i] = &menuItemAutonGoBack;

	menuItemAuton15P.name = "Auton15P";
	menuItemAuton15P.id = ++id;
	menuItemAuton15P.idx = ++i;
	menuItemAuton15P.isDirectional = true;
	screenListAuton[i] = &menuItemAuton15P;

	menuItemAuton5P.name = "Auton5P";
	menuItemAuton5P.id = ++id;
	menuItemAuton5P.idx = ++i;
	menuItemAuton5P.isDirectional = true;
	screenListAuton[i] = &menuItemAuton5P;

	menuItemAuton10P.name = "Auton10P";
	menuItemAuton10P.id = ++id;
	menuItemAuton10P.idx = ++i;
	menuItemAuton10P.isDirectional = true;
	screenListAuton[i] = &menuItemAuton10P;

	menuItemAuton15PRT.name = "Auton2Cone";
	menuItemAuton15PRT.id = ++id;
	menuItemAuton15PRT.idx = ++i;
	menuItemAuton15PRT.isDirectional = true;
	screenListAuton[i] = &menuItemAuton15PRT;

	menuItemAutonNone.name = "AutonNone";
	menuItemAutonNone.id = ++id;
	menuItemAutonNone.idx = ++i;
	menuItemAutonNone.isDirectional = true;
	screenListAuton[i] = &menuItemAutonNone;

	menuItemProgSkills1.name = "Prog. Skills 1";
	menuItemProgSkills1.id = ++id;
	menuItemProgSkills1.idx = ++i;
	screenListAuton[i] = &menuItemProgSkills1;

	i = 0;

	menuItemSideGoBack.name = "Go Back";
	menuItemSideGoBack.id = ++id;
	menuItemSideGoBack.idx = i;
	menuItemSideGoBack.LCDAction = "<    Select    >";
	screenListSides[i] = &menuItemSideGoBack;

	menuItemSideLeft.name = "L";
	menuItemSideLeft.id = ++id;
	menuItemSideLeft.idx = ++i;
	menuItemSideLeft.LCDAction = "<    Select    >";
	screenListSides[i] = &menuItemSideLeft;

	menuItemSideRight.name = "R";
	menuItemSideRight.id = ++id;
	menuItemSideRight.idx = ++i;
	menuItemSideRight.LCDAction = "<    Select    >";
	screenListSides[i] = &menuItemSideRight;

	i = 0;

	menuItemColorGoBack.name = "Go Back";
	menuItemColorGoBack.id = ++id;
	menuItemColorGoBack.idx = i;
	menuItemColorGoBack.LCDAction = "<    Select    >";
	screenListColors[i] = &menuItemColorGoBack;

	menuItemColorBlue.name = "B";
	menuItemColorBlue.id = ++id;
	menuItemColorBlue.idx = ++i;
	menuItemColorBlue.LCDAction = "<    Select    >";
	screenListColors[i] = &menuItemColorBlue;

	menuItemColorRed.name = "R";
	menuItemColorRed.id = ++id;
	menuItemColorRed.idx = ++i;
	menuItemColorRed.LCDAction = "<    Select    >";
	screenListColors[i] = &menuItemColorRed;

	i = 0;

	menuItemPIDGoBack.name = "Go Back";
	menuItemPIDGoBack.id = ++id;
	menuItemPIDGoBack.idx = i;
	menuItemPIDGoBack.LCDAction = "<    Select    >";
	menuItemPIDGoBack.isDirectional = false;
	screenListPID[i] = &menuItemPIDGoBack;

	menuItemPIDDrive.name = "Drive";
	menuItemPIDDrive.id = ++id;
	menuItemPIDDrive.idx = i;
	menuItemPIDDrive.LCDAction = "<    Select    >";
	menuItemPIDDrive.isDirectional = false;
	screenListPID[i] = &menuItemPIDDrive;

	menuItemPIDGyro.name = "Gyro";
	menuItemPIDGyro.id = ++id;
	menuItemPIDGyro.idx = i;
	menuItemPIDGyro.LCDAction = "<    Select    >";
	menuItemPIDGyro.isDirectional = false;
	screenListPID[i] = &menuItemPIDGyro;

	menuItemPIDArm.name = "Arm";
	menuItemPIDArm.id = ++id;
	menuItemPIDArm.idx = i;
	menuItemPIDArm.LCDAction = "<    Select    >";
	menuItemPIDArm.isDirectional = false;
	screenListPID[i] = &menuItemPIDArm;

	menuItemPIDMini4Bar.name = "Mini 4-Bar";
	menuItemPIDMini4Bar.id = ++id;
	menuItemPIDMini4Bar.idx = i;
	menuItemPIDMini4Bar.LCDAction = "<    Select    >";
	menuItemPIDMini4Bar.isDirectional = false;
	screenListPID[i] = &menuItemPIDMini4Bar;

	menuItemPIDMoGoLift.name = "MoGo Lift";
	menuItemPIDMoGoLift.id = ++id;
	menuItemPIDMoGoLift.idx = i;
	menuItemPIDMoGoLift.LCDAction = "<    Select    >";
	menuItemPIDMoGoLift.isDirectional = false;
	screenListPID[i] = &menuItemPIDMoGoLift;

	menuItemPIDCustom.name = "Custom";
	menuItemPIDCustom.id = ++id;
	menuItemPIDCustom.idx = i;
	menuItemPIDCustom.LCDAction = "<    Select    >";
	menuItemPIDCustom.isDirectional = false;
	screenListPID[i] = &menuItemPIDCustom;

	currentMenu = screenListMain;
}













/* competition code from VEX */
#pragma platform(VEX2)
#pragma competitionControl(Competition)

void pre_auton();
task autonomous();
task usercontrol();

bool bStopTasksBetweenModes = true;
#if !defined(VEX2) && !defined(VEX)
#error "Switch to the VEX cortex platform"
#endif

void allMotorsOff();
void stopTasks();
bool isCompetitionMode = false;

task main()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
	displayNextLCDString("Startup");
	wait1Msec(2000);
	clearLCDLine(0);

	pre_auton();

	while (true)
	{
		if (isCompetitionMode)
		{
			// remain in this loop while the robot is disabled
			while (bIfiRobotDisabled)
			{
				while (true)
				{
					if (!bIfiRobotDisabled)
						break;
					wait1Msec(25);
				}
			}

			if (bIfiAutonomousMode)
			{
				startTask(autonomous);

				// Waiting for autonomous phase to end
				while (bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (!bVEXNETActive)
					{
						if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
							allMotorsOff();
					}
					wait1Msec(25);               // Waiting for autonomous phase to end
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}

			else
			{
				startTask(usercontrol);

				// Here we repeat loop waiting for user control to end and (optionally) start
				// of a new competition run
				while (!bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
						allMotorsOff();
					wait1Msec(25);
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}
		}
	}
}

void allMotorsOff()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
#if defined(VEX2)
	motor[port9] = 0;
	motor[port10] = 0;
#endif
}


























/*---------------------------------------------------------------------------*/
/*																			 */
/*							Pre-Autonomous Functions						 */
/*																			 */
/*---------------------------------------------------------------------------*/

/* references to procedures and tasks */
void startUp();
task loadLCDScreen;
task usercontrol;
task PIDMode;

int LCDSelectionScreenTimeoutMs;
MenuItem *selectedProgram;
short LCDScreenMin = menuItemGoToAuton.idx; //minimum index for Screen List
short LCDScreenMax = menuItemBatteryLevel.idx; //maximum index for Screen List
short LCDScreen = 0; //current index of menuItem
bool autonomousSide = SIDE_LEFT; //side selected for autonomous
bool autonomousColor = COLOR_BLUE;
int LCDActiveTime = 0; //amount of time LCD has been inactive

/* What the second line of the LCD should display on a menuItem */
string LCDAction = "<     Start    >";

/* if  this button is pressed the LCD will be controllable from the joystick */
bool isJoystickLCDMode() {
	return (vexRT[Btn7R] == 1);
}


void waitForLCDButtonRelease()
{
	//while these buttons are being pressed, keep waiting
	while (!(nLCDButtons == 0 && vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0))
	{
		wait1Msec(10);
	}
}

bool isTaskActive()
{
	//check if the main tasks are active
	if (getTaskState(usercontrol) != taskStateStopped || getTaskState(autonomous) != taskStateStopped || getTaskState(PIDMode) != taskStateStopped)
		return true;

	return false;
}


void waitForLCDButtonPress()
{
	LCDActiveTime = 0;

	if (selectedProgram == NULL || !isTaskActive()) //if the robot has just started up
	{
		//while neither of these buttons are pressed, keep waiting
		while ( nLCDButtons == 0 && vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0 )
		{
			wait1Msec(10);
			LCDActiveTime++;

			if (LCDActiveTime > LCDSelectionScreenTimeoutMs / 10)
			{
				break;
			}
		}
	}
	else
	{
		while (nLCDButtons == 0 && ( !isJoystickLCDMode() || (vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0) ))
		{
			wait1Msec(10);
		}
	}
}


/* Increment the index or jump to start of list */
void LCDNextScreen()
{
	if (LCDScreen < LCDScreenMax) LCDScreen++;
	else LCDScreen = LCDScreenMin;
}

/* Decrement the index or jump to end of list */
void LCDPreviousScreen()
{
	if (LCDScreen > LCDScreenMin) LCDScreen--;
	else LCDScreen = LCDScreenMax;
}


void displayBatteryLevelOnLCD()
{
	clearLCDLine(0);
	clearLCDLine(1);
	string mainBattery, backupBattery;

	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V');
	sprintf(backupBattery, "%1.2f%c", SensorValue[secondaryBattery] / 280.0, 'V');

	displayLCDString(0, 0, "Primary: ");
	displayNextLCDString(mainBattery);
	displayLCDString(1, 0, "Secondary: ");
	displayNextLCDString(backupBattery);
}

void reconfigureMenu(void* screenList, byte newLCDScreen, byte newLCDScreenMin, byte newLCDScreenMax)
{
	currentMenu = screenList;
	LCDScreen = newLCDScreen;
	LCDScreenMin = newLCDScreenMin;
	LCDScreenMax = newLCDScreenMax;
}

void displayProgram()
{
	string programName = (currentMenu[LCDScreen]).name; //name of displayed menuItem
	displayLCDCenteredString(0, currentMenu[LCDScreen].name); //display menuItem name
	displayLCDCenteredString(1, LCDAction); //display possible action


	/* if current menu screen is the battery level screen, display battery level */
	if (currentMenu[LCDScreen].id == menuItemBatteryLevel.id)
	{
		displayBatteryLevelOnLCD();
	}
	/* if current menu screen is on the current program screen, display its name */
	else if (currentMenu[LCDScreen].id == menuItemCurrentProgram.id)
	{
		displayLCDCenteredString(0, "Daud-_-Jaan");
		displayLCDCenteredString(1, (*selectedProgram).name);
	}
	/* If the current menu is the directions menu add an L or an R to the end of the auton program name to indicate direction */
	else if (currentMenu == screenListSides && ( currentMenu[LCDScreen].id == menuItemSideLeft.id || currentMenu[LCDScreen].id == menuItemSideRight.id) )
	{
		programName = (*selectedProgram).name;
		if (currentMenu[LCDScreen].id == menuItemSideLeft.id) programName += "L";
		else programName += "R";
		displayLCDCenteredString(0, programName);
	}
	else if (currentMenu == screenListColors && ( currentMenu[LCDScreen].id == menuItemColorBlue.id || currentMenu[LCDScreen].id == menuItemColorRed.id) )
	{
		programName = (*selectedProgram).name;
		if (currentMenu[LCDScreen].id == menuItemColorBlue.id) programName += "B";
		else programName += "R";
		displayLCDCenteredString(0, programName);
	}
	/* If the current menu item is strictly a navigation item, change the second line to read "Select" */
	else if (currentMenu[LCDScreen].id == menuItemSideGoBack.id || currentMenu[LCDScreen].id == menuItemColorGoBack.id || currentMenu[LCDScreen].id == menuItemAutonGoBack.id || currentMenu[LCDScreen].id == menuItemGoToAuton.id || currentMenu[LCDScreen].isDirectional)
	{
		displayLCDCenteredString(1, "<    Select    >");
	}
	else if (currentMenu[LCDScreen].id == menuItemResetGyro.id)
	{
		waitForLCDButtonRelease();
		string gyroValue;
		displayLCDString(1, 0, "< Reset (");
		/* Get value of gyro sensor and print it to the LCD Screen */
		while (nLCDButtons == 0 && vexRT[BTN_JOY_LCD_NEXT] == 0 && vexRT[BTN_JOY_LCD_PREVIOUS] == 0 && vexRT[BTN_JOY_LCD_SELECT] == 0)
		{
			sprintf(gyroValue, "%4.0f%c", SensorValue[gyro]); //convert to string format to 4 digits
			gyroValue += ")";
			displayLCDString(1, 9, gyroValue);
			displayLCDString(1, 15, ">");
		}
	}
	/* Display the current mode of the Robot when on this menu screen. */
	else if (currentMenu[LCDScreen].id == menuItemSwitchCompetitionMode.id)
	{
		if (isCompetitionMode) displayLCDCenteredString(0, "Comp Mode Active");
		else displayLCDCenteredString(0, "Test Mode Active");
		displayLCDCenteredString(1, "< Switch  Mode >");
	}


	waitForLCDButtonPress();

	/* If the Left and Right LCD Buttons are pressed, display the battery level. */
	if (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[BTN_JOY_LCD_NEXT] == 1 && vexRT[BTN_JOY_LCD_PREVIOUS] == 1))
	{
		while (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[BTN_JOY_LCD_NEXT] == 1 && vexRT[BTN_JOY_LCD_PREVIOUS] == 1))
		{
			displayBatteryLevelOnLCD();
		}
	}
	/* If the left LCD Button is pressed (or joystick equivelent), go to the previous menuItem in list (Previous Screen) */
	else if (nLCDButtons == LCDLeftButton || vexRT[BTN_JOY_LCD_PREVIOUS] == 1)
	{
		waitForLCDButtonRelease();
		LCDPreviousScreen();
	}
	/* If the right LCD Button is pressed (or joystick equivelent), go to the next menuItem in the list (Next screen) */
	else if (nLCDButtons == LCDRightButton || vexRT[BTN_JOY_LCD_NEXT] == 1)
	{
		waitForLCDButtonRelease();
		LCDNextScreen();
	}
	/* If the center LCD Button is pressed (or joystick equivelent)... */
	else if ( (nLCDButtons == LCDCenterButton || vexRT[BTN_JOY_LCD_SELECT] == 1) && currentMenu[LCDScreen].id != menuItemBatteryLevel.id && currentMenu[LCDScreen].id != menuItemCurrentProgram.id)
	{
		waitForLCDButtonRelease();
		/* If LCD is on the Autonomous menu screen, go to the direction selection screen */
		if (currentMenu == screenListAuton && currentMenu[LCDScreen].id != menuItemAutonGoBack.id && currentMenu[LCDScreen].isDirectional)
		{
			selectedProgram = &currentMenu[LCDScreen];
			reconfigureMenu(screenListSides, 1, 0, SCREEN_LIST_SIDES_LENGTH - 1);
		}
		else if (currentMenu == screenListSides && currentMenu[LCDScreen].id != menuItemSideGoBack.id)
		{
			autonomousSide = (currentMenu[LCDScreen].id == menuItemSideLeft.id) ? SIDE_LEFT : SIDE_RIGHT;
			reconfigureMenu(screenListColors, 1, 0, SCREEN_LIST_COLORS_LENGTH - 1);
		}
		/* If the current menu Item is redirecting to the autonomous screen, go to the menu screen */
		else if (currentMenu[LCDScreen].id == menuItemSideGoBack.id || currentMenu[LCDScreen].id == menuItemGoToAuton.id)
		{
			reconfigureMenu(screenListAuton, 1, 0, SCREEN_LIST_AUTON_LENGTH - 1);
		}
		else if (currentMenu[LCDScreen].id == menuItemColorGoBack.id)
		{
			reconfigureMenu(screenListSides, 1, 0, SCREEN_LIST_SIDES_LENGTH - 1);
		}
		/* If current screen is the menu Item for going back to main screen... */
		else if (currentMenu[LCDScreen].id == menuItemAutonGoBack.id || currentMenu[LCDScreen].id == menuItemPIDGoBack.id)
		{
			LCDScreenMax = SCREEN_LIST_MAIN_LENGTH - 1;
			/* If in hardcoded competition mode, allow competition mode switch option */
			currentMenu = screenListMain;
			if (isCompetitionMode)
			{
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else LCDScreenMin = menuItemUserControl.idx;
			LCDScreen = menuItemGoToAuton.idx;
		}
		/* If the current screen is the reset gyro screen, reset the gyro and notify the user */
		else if (currentMenu[LCDScreen].id == menuItemResetGyro.id)
		{
			SensorValue[gyro] = 0;
			displayLCDCenteredString(0, "Gyro Reset!");
			clearLCDLine(1);
			wait1Msec(1000);
		}
		/* If the current screen is the switch mode screen... */
		else if (currentMenu[LCDScreen].id == menuItemSwitchCompetitionMode.id)
		{
			isCompetitionMode = !isCompetitionMode;
			if (!isCompetitionMode) LCDAction = "<     Start    >";
			else LCDAction = "<    Select    >";
			displayLCDCenteredString(0, "Mode Switched!");
			clearLCDLine(1);
			wait1Msec(1000);

			/* If it is currently in competition mode, make usercontrol and PID mode unavailable.
			If hardcoded competition mode, don't show the switch comeptition mode option. */
			if (isCompetitionMode)
			{
				currentMenu = screenListMain;
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.idx;
				stopTasks();
				startUp();
			}
		}
		else if (currentMenu[LCDScreen].id == menuItemPIDMode.id)
		{
			reconfigureMenu(screenListPID, 1, 0, SCREEN_LIST_PID_LENGTH - 1);
		}
		else
		{
			/* If a direction menu item is pressed, update the direction variable. */
			if (currentMenu[LCDScreen].id ==  menuItemColorBlue.id) autonomousColor = COLOR_BLUE;
			else if (currentMenu[LCDScreen].id ==  menuItemColorRed.id) autonomousColor = COLOR_RED;
			else selectedProgram = &currentMenu[LCDScreen];

			LCDScreenMax = SCREEN_LIST_MAIN_LENGTH - 1;
			LCDScreen = menuItemCurrentProgram.idx;
			currentMenu = screenListMain;

			/* If it is currently in competition mode, make usercontrol and PID mode unavailable.
			If hardcoded competition mode, don't show the switch comeptition mode option. */
			if (isCompetitionMode)
			{
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.idx;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.idx;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.idx;
				stopTasks();
				startUp();
			}
		}
	}
}


task loadLCDScreen() // Task responsible for keeping LCD Screen running.
{
	while (true)
	{
		displayProgram();
	}
}




int waitForJoystickButtonPress() // Gets joystick input and returns the index of the current button pressed.
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	int count = 0;
	int i = 0;
	int buttonPressed;

	while (true)
	{
		count = 0;
		for (i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1)
			{
				count++;
				buttonPressed = i;
			}
		}
		if (count == 1) return buttons[buttonPressed];
	}
}


void waitForJoystickButtonRelease() // Waits for all joystick buttons to be released.
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	bool buttonReleased = true;
	while (true)
	{
		buttonReleased = true;
		for (int i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1) buttonReleased = false;
		}
		if (buttonReleased == true) break;
	}
}



void ResetAllSensors()
{
	int sensorPorts[] = { in1, in2, in3, in4, in5, in6, in7, in8, dgtl1,
		dgtl2, dgtl3, dgtl4, dgtl5, dgtl6, dgtl7, dgtl8,
		dgtl9, dgtl10, dgtl11, dgtl12 };
	for (int i = 0; i < 20; i++)
	{
		SensorValue[sensorPorts[i]] = 0;
	}
}


















void pre_auton()
{
	bStopTasksBetweenModes = true; // Extremely glitchy when disabled
	populateMenuItems(); // Update menuItem arrays
	stopTasks(); // Stop all non-main tasks

	/* enable competition mode by default if flag is set */
#ifdef competitionEnabled
	isCompetitionMode = true;
#endif

	if (isLCDEnabled)
	{
		selectedProgram = NULL;
		/* If not hardcoded competition mode, allow User Control option */
#ifndef competitionEnabled
		LCDScreenMin = menuItemUserControl.id;
#else
		LCDScreenMin = menuItemGoToAuton.id;
#endif

		LCDScreenMax = menuItemBatteryLevel.id;
		bLCDBacklight = true; // Turn on LCD Backlight

		/* If not competition mode, set action string to "Start", stop all tasks, and restart LCD Screen */
		if (!isCompetitionMode)
		{
			LCDAction = "<     Start    >";
			selectedProgram = startupLCDProgram;
			LCDScreen = menuItemUserControl.id;
			stopTasks();
			startUp();
		}
		else
		{
			LCDAction = "<    Select    >";
			LCDScreen = menuItemGoToAuton.id;
		}

		displayLCDCenteredString(0, "Daud Jaan");
		displayLCDCenteredString(1, "99 Triple X");
		wait1Msec(1500);
#ifndef competitionEnabled

		/* Password Lock */
		if (PASSWORD_ENABLED)
		{
			bool correctPassword = false;
			int incorrectAttempts = 3;
			while (!correctPassword)
			{
				displayLCDCenteredString(0, "Enter Password");
				displayLCDCenteredString(1, "");
				int correctCode[5] = { Btn5D, Btn6U, Btn7D, Btn6U, Btn8R };
				int code[5];

				/* Get joystick inputs from user and store in array */
				for (int i = 0; i < 5; i++)
				{
					waitForJoystickButtonPress();
					code[i] = waitForJoystickButtonPress();
					waitForJoystickButtonRelease();
					displayLCDString(1, 6 + i, "*");
				}

				correctPassword = true;

				/* Check if entered code matches password */
				for (int i = 0; i < 5; i++)
				{
					if (code[i] != correctCode[i]) correctPassword = false;
				}

				/* If incorrect password, decrement attempt number and notify user */
				if (!correctPassword)
				{
					incorrectAttempts--;
					displayLCDCenteredString(0, "Wrong Password");
					displayLCDCenteredString(1, "**************");
					wait1Msec(1500);

					string attempts = "";
					sprintf(attempts, "%d", incorrectAttempts);
					attempts += " Attempts Left";
					displayLCDCenteredString(0, "You Have");
					displayLCDCenteredString(1, attempts);
					wait1Msec(1500);

					/* If no more attempts left, shutdown Robot. */
					if (incorrectAttempts == 0)
					{
						displayLCDCenteredString(0, "Bye Bye");
						displayLCDCenteredString(1, "");
						wait1Msec(2000);
						stopAllTasks();
						stopTask(loadLCDScreen);
						stopTask(main);
					}
				}
			}
		}
#endif

		ResetAllSensors();
		stopTask(loadLCDScreen);
		startTask(loadLCDScreen);
	}
}























/*---------------------------------------------------------------------------*/
/*																			 */
/*								Autonomous Task	 							 */
/*																			 */
/*---------------------------------------------------------------------------*/


const float leftDriveMultiplier = (10.0/10.0);
const float rightDriveMultiplier = (10.0/10.0);
short potentiometerArmLimit = 0;


short getArmSensorValue() { return (SensorValue[potentiometerArm] + ARM_POTENTIOMETER_OFFSET) * ARM_POTENTIOMETER_MULTIPLIER; }
short getMini4BarSensorValue() { return (SensorValue[potentiometerMini4Bar] + MINI_4_BAR_POTENTIOMETER_OFFSET) * MINI_4_BAR_POTENTIOMETER_MULTIPLIER; }
short getMoGoLiftSensorValue() { return (SensorValue[potentiometerMoGoLift] + MOGO_LIFT_POTENTIOMETER_OFFSET) * MOGO_LIFT_POTENTIOMETER_MULTIPLIER; }
short getGyroSensorValue() { return SensorValue[gyro] * GYRO_MULTIPLIER; }


bool SetArmLimit() // Set new arm limit everytime limitswitch is pressed.
{
	if ((SensorValue[limitSwitchArm1] == 1 || SensorValue[limitSwitchArm2] == 1) && (getArmSensorValue() < ARM_POTENTIOMETER_MIN_VALUE + 200) * ARM_POTENTIOMETER_MULTIPLIER)
	{
		potentiometerArmLimit = SensorValue[potentiometerArm];
		return true;
	}
	return false;
}

void setDriveMotorPower(short leftMotorPower, short rightMotorPower) // Set Drive motor power with seperate power for each side
{
	motor[motorDriveRightFront] = rightMotorPower * rightDriveMultiplier;
	motor[motorDriveRightBack] = rightMotorPower * rightDriveMultiplier;

	motor[motorDriveLeftFront] = leftMotorPower * leftDriveMultiplier;
	motor[motorDriveLeftBack] = leftMotorPower * leftDriveMultiplier;
}

void setDriveMotorPower(short motorPower) // Set equal drive motor power for all motors
{
	setDriveMotorPower(motorPower, motorPower);
}

void setArmMotorPower(short motorPower) // Set arm motor power
{
	motor[motorArmLeft] = motorPower;
	motor[motorArmRight] = motorPower;
}


void setGoliathMotorPower(short motorPower) // Set individual claw motor power
{
	motor[motorGoliath] = motorPower;
}

void setMini4BarMotorPower(short motorPower)
{
	motor[motorMini4Bar] = motorPower;
}

void setMoGoLiftMotorPower(short motorPower)
{
	motor[motorMoGoLiftLeft] = motorPower;
	motor[motorMoGoLiftRight] = motorPower;
}


bool autonomousReady = true;

void waitUntilReady()
{
	wait1Msec(10);
	while (!autonomousReady) { }
}

/* Perform timed action for given amount of time with individual motor powers */
void actionTimed(Action action, int time, int leftMotorPower, int rightMotorPower)
{
	autonomousReady = false;

	SetArmLimit();
	clearTimer(T1);
	if (action == A_DRIVE) setDriveMotorPower(leftMotorPower, rightMotorPower);
	else if (action == A_ARM) setArmMotorPower(leftMotorPower);
	else if (action == A_GOLIATH) setGoliathMotorPower(leftMotorPower);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(leftMotorPower);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(leftMotorPower);

	while (time1[T1] <= time) SetArmLimit();

	if (action == A_DRIVE) setDriveMotorPower(0,0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_GOLIATH) setGoliathMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);


	autonomousReady = true;
}

/* Perform timed action for given amount of time with equal motor powers */
void actionTimed(Action action, int time, int motorPower)
{
	actionTimed(action, time, motorPower, motorPower);
}



/* Perform action until sensor passes given value */
void actionUntilAtGoalPoint(Action action, short goalPoint, int motorPower)
{
	autonomousReady = false;

	SetArmLimit();
	byte multiplier = 1;

	if (SensorValue[encoderDriveLeft] > goalPoint ||
		getArmSensorValue() > goalPoint ||
	getMini4BarSensorValue() > goalPoint ||
	getMoGoLiftSensorValue() > goalPoint) multiplier = -1;

	motorPower = abs(motorPower) * multiplier;

	if (action == A_DRIVE)
	{
		setDriveMotorPower(motorPower, motorPower);
		while (SensorValue[encoderDriveLeft] * multiplier < goalPoint * multiplier) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(motorPower);
		while (getArmSensorValue() * multiplier < goalPoint * multiplier) { SetArmLimit(); }
	}
	else if (action == A_MINI_4_BAR)
	{
		setArmMotorPower(motorPower);
		while (getMini4BarSensorValue() * multiplier < goalPoint * multiplier) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(motorPower);
		while (getMoGoLiftSensorValue() * multiplier < goalPoint * multiplier) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}


/* Perform action until sensor value is greater than given value with individual motor power */
void actionUntilOverGoalPoint(Action action, short goalPoint, int leftMotorPower, int rightMotorPower)
{
	autonomousReady = false;

	SetArmLimit();
	if (action == A_DRIVE)
	{
		SensorValue[encoderDriveLeft] = 0;
		setDriveMotorPower(leftMotorPower, rightMotorPower);
		while (SensorValue[encoderDriveLeft] < goalPoint) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(leftMotorPower);
		while (getArmSensorValue() < goalPoint)
		{
			SetArmLimit();
		}
	}
	else if (action == A_MINI_4_BAR)
	{
		setMini4BarMotorPower(leftMotorPower);
		while (getMini4BarSensorValue() < goalPoint) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(leftMotorPower);
		while (getMoGoLiftSensorValue() < goalPoint) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}


/* Perform action until sensor value is over given value with equal motor power */
void actionUntilOverGoalPoint(char action, short goalPoint, int motorPower)
{
	actionUntilOverGoalPoint(action, goalPoint, motorPower, motorPower);
}


/* Perform action until sensor value is less than given value with individual motor power */
void actionUntilUnderGoalPoint(Action action, short goalPoint, int leftMotorPower, int rightMotorPower)
{
	autonomousReady = false;

	SetArmLimit();
	if (action == A_DRIVE)
	{
		SensorValue[encoderDriveLeft] = 0;
		setDriveMotorPower(leftMotorPower, rightMotorPower);
		while (SensorValue[encoderDriveLeft] > goalPoint) { }
	}
	else if (action == A_ARM)
	{
		setArmMotorPower(leftMotorPower);
		while (getArmSensorValue() > goalPoint)
		{
			SetArmLimit();
		}
	}
	else if (action == A_MINI_4_BAR)
	{
		setMini4BarMotorPower(leftMotorPower);
		while (getMini4BarSensorValue() > goalPoint) { }
	}
	else if (action == A_MOGO_LIFT)
	{
		setMoGoLiftMotorPower(leftMotorPower);
		while (getMoGoLiftSensorValue() > goalPoint) { }
	}

	if (action == A_DRIVE) setDriveMotorPower(0);
	else if (action == A_ARM) setArmMotorPower(0);
	else if (action == A_MOGO_LIFT) setMoGoLiftMotorPower(0);
	else if (action == A_MINI_4_BAR) setMini4BarMotorPower(0);

	autonomousReady = true;
}

/* Perform action until sensor value is less than given value with equal motor power */
void actionUntilUnderGoalPoint(char action, short goalPoint, int motorPower)
{
	actionUntilUnderGoalPoint(action, goalPoint, motorPower, motorPower);
}





void drivePIDControl(short goalPoint)
{

	float pGain = (8.0/10.0);
	float iGain = (10.0/1000.0);
	float dGain = (3.0/1.0);

	autonomousReady = false;

	goalPoint = SensorValue[encoderDriveRight] + goalPoint;

	int error = goalPoint - SensorValue[encoderDriveRight];
	int errorDifference = 0;
	int newPower = 0;
	int errorSum = 0;
	int timeInitial = time1[T4];

	while (time1[T4] - timeInitial < 200)
	{
		errorDifference = error - (goalPoint - SensorValue[encoderDriveRight]);
		error = goalPoint - SensorValue[encoderDriveRight];
		errorSum += error;

		if (abs(error) < 15) errorSum = 0;
		else timeInitial = time1[T4];

		/* Prevent wind-up. Set max integral gain to full power */
		if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;

		/* If power is too low, set minimum power required to move motor */
		//if (newPower > -minPower && error < 0) newPower = -minPower;
		//else if (newPower < minPower && error > 0) newPower = minPower;
		setDriveMotorPower(newPower, newPower);

		wait1Msec(15);
	}
	setDriveMotorPower(0,0);
	autonomousReady = true;
}

/* Drive for specified amount of time while maintaining direction */
void gyroDrive(int power, int time, int deg)
{
	autonomousReady = false;

	deg *= 10;
	float pGain = (500.0/1000.0);
	int error = 0;

	clearTimer(T1);
	while (time1[T1] < time)
	{
		error = getGyroSensorValue() - deg;
		if (getGyroSensorValue() > deg)
		{
			setDriveMotorPower( power - error * pGain, power );
		}
		else if (getGyroSensorValue() < deg)
		{
			setDriveMotorPower( power, power - error * pGain );
		}
		else
		{
			setDriveMotorPower(power);
		}
	}

	autonomousReady = true;
}



/* Face a certain bearing */
void gyroFace(int degrees)
{
	autonomousReady = false;

	degrees *= GYRO_MULTIPLIER;
	degrees *= 10;
	int undershoot = 160;
	//degrees = (getGyroSensorValue() - degrees * 10) / 10;
	int error = degrees - getGyroSensorValue();
	int left = 0, right = 0;
	if (degrees < 0){left = -1; right = 1;}
	else if (degrees > 0){left = 1; right = -1; }

	if (abs(error) > undershoot)
	{
		if (error > 0)
		{
			while (degrees - undershoot - getGyroSensorValue() > 0)
			{
				setDriveMotorPower(127 * left, 127 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees + undershoot - getGyroSensorValue() < 0)
			{
				setDriveMotorPower(127 * left, 127 * right);
			}
		}
	}
	else if (abs(error) < undershoot)
	{
		if (error > 0)
		{
			while (degrees - getGyroSensorValue() > 0)
			{
				setDriveMotorPower(50 * left, 50 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees - getGyroSensorValue() < 0)
			{
				setDriveMotorPower(50 * left, 50 * right);
			}
		}
	}

	setDriveMotorPower((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(250);
	setDriveMotorPower(0,0);

	/*	if (degrees - getGyroSensorValue() > 50)
	{
	while (degrees - getGyroSensorValue() > 0)
	{
	setDriveMotorPower(90 * left, 90 * right);
	}
	}
	else if (degrees - getGyroSensorValue() < -50)
	{
	while (degrees - getGyroSensorValue() < 0)
	{
	setDriveMotorPower(90 * left, 90 * right);
	}
	}

	setDriveMotorPower((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(50);
	setDriveMotorPower(0,0);*/

	autonomousReady = true;
}



/* Face an absolute directional bearing */
void gyroPIDControl(short goalPoint)
{
	float pGain = (1.5);
	float iGain = (0.01);
	float dGain = (20.0);

	autonomousReady = false;

	goalPoint *= 10; // Convert degree format to gyro format
	goalPoint *= GYRO_MULTIPLIER;

	int error = goalPoint - getGyroSensorValue();
	int newPower = 0;
	const int minPower = 0;
	float errorSum = 0;
	int errorDifference = 0;
	const int errorMargin = 10;
	int timeInitial = time1[T4];

	while (time1[T4] - timeInitial < 150)
	{
		errorDifference = error - (goalPoint  - getGyroSensorValue());
		error = goalPoint  - getGyroSensorValue();
		errorSum += error / 10.0;

		if (abs(error) < 19) errorSum = 0;
		if (abs(error) > 20) timeInitial = time1[T4];

		/* Prevent wind-up. Set maximum integral gain to 127 power. */
		if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;

		/* Set motor power to minimum required to move if lower than minimum */
		//if (newPower > -minPower && error < 0) newPower = -minPower;
		//else if (newPower < minPower && error > 0) newPower = minPower;

		setDriveMotorPower(newPower * (-1), newPower);

		wait1Msec(5);

		//if (abs(getGyroSensorValue() - goalPoint) < 6 && abs(newPower) < 10) wait1Msec(100);
	}
	setDriveMotorPower(0,0);

	autonomousReady = true;
}

/* Rotate from current bearing */
void gyroRotate(int deg)
{
	autonomousReady = false;
	short goalPoint = (getGyroSensorValue() + deg * 10);
	while (goalPoint > 3600) goalPoint -= 3600;
	while (goalPoint < -3600) goalPoint += 3600;
	gyroFace(goalPoint);
}



void armPIDControl(short goalPoint, WaitForAction stopWhenMet)
{
	float pGain = (2.8/10.0);
	float iGain = (3.0/1000.0);
	float dGain = (11.0/10.0);

	autonomousReady = false;

	SetArmLimit();
	goalPoint *= ARM_POTENTIOMETER_MULTIPLIER;

	int errorSum = 0;
	int errorDifference = 0;
	int error = goalPoint - getArmSensorValue();
	int newPower = 0;

	int timeInitial = time1[T4];

	while (time1[T4] - timeInitial < 300 || stopWhenMet == WAIT_NONE)
	{
		SetArmLimit();
		errorDifference = error - (goalPoint - getArmSensorValue());
		error = goalPoint - getArmSensorValue();
		errorSum = errorSum + error / 10.0;

		if (abs(error) >= 50) timeInitial = time1[T4];

		/* Prevent wind-up. Set max integral gain to max power. */
		if (errorSum * iGain > 127.0) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127.0) errorSum = -127.0 / iGain;

		newPower = error * pGain + errorSum * iGain - errorDifference * dGain;

		setArmMotorPower(newPower);
		wait1Msec(15);
	}

	autonomousReady = true;
}




void mini4BarPIDControl(short goalPoint)
{
	float pGain = (2.8/10.0);

	autonomousReady = false;
	goalPoint *= MINI_4_BAR_POTENTIOMETER_MULTIPLIER;

	int error = goalPoint - getMini4BarSensorValue();
	int newPower = 0;

	int timeInitial = time1[T4];

	while (time1[T4] - timeInitial < 100)
	{
		error = goalPoint - getMini4BarSensorValue();

		if (abs(error) >= 50) timeInitial = time1[T4];

		newPower = error * pGain;

		setArmMotorPower(newPower);
		wait1Msec(15);
	}

	autonomousReady = true;
}

void mini4BarRetract()
{
	mini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE);
}

void mini4BarExtend()
{
	mini4BarPIDControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE);
}



void moGoRetract()
{
	while (getMoGoLiftSensorValue() < MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER)
	{
		setMoGoLiftMotorPower(127);
	}
	setMoGoLiftMotorPower(0);
}

void moGoExtend()
{
	float dGain = 2.0;

	int error = MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue();
	int errorDifference = 0;

	while (getMoGoLiftSensorValue() > MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER)
	{
		errorDifference = error - (MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue());
		error = MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue();
		setMoGoLiftMotorPower(50 - dGain * abs(errorDifference) );
	}
	setMoGoLiftMotorPower(0);
}




/* Variables used by tasks */
int tDrivePIDGoalPoint = 0;
short tArmPIDGoalPoint = ARM_POTENTIOMETER_HIGH_GOAL_VALUE;
short tGyroPIDGoalPoint = 0;
State tMini4BarGoalState = STATE_EXTENDED;
State tMoGoLiftGoalState = STATE_EXTENDED;

/*  */
WaitForAction waitForTArmPID = WAIT;

/* Status of Autonomous Tasks */
bool isTDriveReady = true;
bool isTMini4BarReady = true;
bool isTMoGoLiftReady = true;
bool isTArmReady = true;
bool isTGyroFaceReady = true;
bool isTGyroPIDReady = true;





/* Task Hosts for PIDs */
task tDrivePIDControl()
{
	isTDriveReady = false;

	drivePIDControl(tDrivePIDGoalPoint);

	isTDriveReady = true;
}


task tGyroPIDControl()
{
	isTGyroPIDReady = false;

	gyroPIDControl(tGyroPIDGoalPoint);

	isTGyroPIDReady = true;
}

task tGyroFace()
{
	isTGyroFaceReady = false;

	gyroFace(tGyroPIDGoalPoint);

	isTGyroFaceReady = true;
}


task tArmPIDControl()
{
	isTArmReady = false;

	SetArmLimit();
	armPIDControl(tArmPIDGoalPoint, waitForTArmPID);

	isTArmReady = true;
}


task tKeepArmDown()
{
	isTArmReady = false;

	while (SensorValue[limitSwitchArm1] == 0 && SensorValue[limitSwitchArm2] == 0) setArmMotorPower(-127);
	setArmMotorPower(0);

	isTArmReady = true;
}

task tMini4Bar()
{
	isTMini4BarReady = false;

	if (tMini4BarGoalState == STATE_EXTENDED) mini4BarExtend();
	else if (tMini4BarGoalState == STATE_RETRACTED) mini4BarRetract();

	isTMini4BarReady = true;
}

task tMoGoLift()
{
	isTMoGoLiftReady = false;

	if (tMoGoLiftGoalState == STATE_EXTENDED) moGoExtend();
	else if (tMoGoLiftGoalState == STATE_RETRACTED) moGoRetract();

	isTMoGoLiftReady = true;
}


/* Procedures for starting autonomous tasks */
void startTKeepArmDown()
{
	stopTask(tKeepArmDown);
	stopTask(tArmPIDControl);
	startTask(tKeepArmDown);
}

void startTDrivePID(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tDrivePIDGoalPoint = goalPoint;
	startTask(tDrivePIDControl);
}

void startTArmPID(int goalPoint, WaitForAction stopWhenMet)
{
	stopTask(tArmPIDControl);
	stopTask(tKeepArmDown);
	tArmPIDGoalPoint = goalPoint;
	waitForTArmPID = stopWhenMet;

	startTask(tArmPIDControl);
}


void startTGyroPID(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	startTask(tGyroPIDControl);
}

void startTGyroFace(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	startTask(tGyroFace);
}

void startTMini4Bar(State GoalState)
{
	stopTask(tMini4Bar);
	tMini4BarGoalState = GoalState;
	startTask(tMini4Bar);
}

void startTMoGoLift(State GoalState)
{
	stopTask(tMoGoLift);
	tMoGoLiftGoalState = GoalState;
	startTask(tMoGoLift);
}

/* Procedures for waiting for tasks */

void waitForTDrive()
{
	wait1Msec(10);
	while (!isTDriveReady) { }
}

void waitForTArm()
{
	wait1Msec(10);
	while (!isTArmReady) { }
}


void waitForTGyroFace()
{
	wait1Msec(10);
	while (!isTGyroFaceReady) { }
}

void waitForTGyroPID()
{
	wait1Msec(10);
	while (!isTGyroPIDReady) { }
}

void waitForTMini4Bar()
{
	wait1Msec(10);
	while (!isTMini4BarReady) { }
}

void waitForTMoGoLift()
{
	wait1Msec(10);
	while (!isTMoGoLiftReady) { }
}

void waitForAllPIDTasks()
{
	wait1Msec(10);
	while (!isTArmReady) { }
	while (!isTDriveReady) { }
	while (!isTGyroFaceReady) { }
	while (!isTGyroPIDReady) { }
	while (!isTMini4BarReady) { }
	while (!isTMoGoLiftReady) { }
}


/* Procedure for killing all autonomous tasks. */
void stopAllTPID()
{
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tGyroPIDControl);
	stopTask(tGyroFace);
	stopTask(tKeepArmDown);
	stopTask(tMini4Bar);
	stopTask(tMoGoLift);
}


void goliathIntake(char power)
{
	autonomousReady = false;

	stopTask(tMini4Bar);
	stopTask(tArmPIDControl);
	startTMini4Bar(STATE_EXTENDED);
	while (getMini4BarSensorValue() < (MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE + 200) * MINI_4_BAR_POTENTIOMETER_MULTIPLIER) { }
	startTArmPID(ARM_POTENTIOMETER_MIN_VALUE, WAIT);
	setGoliathMotorPower(power);
	wait1Msec(200);
	setGoliathMotorPower(GOLIATH_REST_POWER);
	stopTask(tArmPIDControl);
	startTArmPID(ARM_POTENTIOMETER_CONE_HEIGHT_VALUE + 200, WAIT);

	autonomousReady = true;
}

void goliathIntake()
{
	goliathIntake(GOLIATH_INTAKE_POWER);
}



task playMissionImpossibleMusic;

task autonomous()
{
	startTask(playMissionImpossibleMusic);
	if (isLCDEnabled)
	{
		if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);
		displayLCDCenteredString(0, "Daud Jaan");
		displayLCDCenteredString(1, (*selectedProgram).name);
	}
	/*	if ((*selectedProgram).id == menuItemAuton15P.id)
	{
	startTDrivePID(600);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 400, true);
	wait1Msec(200);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 37, false);
	waitForTClaw();
	stopTask(tArmConePIDControl);

	startTKeepArmDown();
	waitForTArm();
	waitForTDrive();

	startTDrivePID(800);
	waitForTDrive();

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	stopAllTPID();
	grab(127);
	wait1Msec(300);
	grab(40);
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, true);
	if (autonomousSide == SIDE_BLUE) startTGyroPID(5);
	else if (autonomousSide == SIDE_RED) startTGyroPID(-5);
	waitForTArm();
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);
	stopTask(tGyroPIDControl);

	startTDrivePID(-1500);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-32);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(32);
	waitForTGyroPID();

	startTDrivePID(-650);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-135);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(135);
	waitForTGyroPID();

	setDriveMotorPower(127, 127);
	wait1Msec(1300);

	stopTask(tArmConePIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE, true);
	waitForTClaw();

	setDriveMotorPower(-127, -127);
	wait1Msec(600);
	setDriveMotorPower(0);
	}
	else if ((*selectedProgram).id == menuItemAuton15PRT.id)
	{
	startTDrivePID(200);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 300, true);
	waitForTArm();

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 500, true);
	waitForTClaw();

	waitForTDrive();
	startTDrivePID(-20);
	waitForTDrive();
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE, true);
	waitForTArm();
	stopAllTPID();

	actionUntilOverGoalPoint(A_CLAW, CLAW_OPEN_POTENTIOMETER_VALUE + 700, 127);
	grab(127);
	wait1Msec(350);
	grab(40);

	startTArmConePID(HIGH_CARRY_ARM_POTENTIOMETER_VALUE + 250, true);
	startTDrivePID(100);
	waitForTArm();
	waitForTDrive();

	startTDrivePID(450);
	waitForTDrive();

	stopTask(tArmConePIDControl);
	setArmMotorPower(-60);
	wait1Msec(700);
	setArmMotorPower(0);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE);
	startTDrivePID(-400);
	waitForTDrive();
	stopTask(tClawPIDControl);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 250);
	startTArmConePID(potentiometerArmLimit, true);
	if (autonomousSide == SIDE_RED) startTGyroPID(-90);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(90);
	waitForTGyroPID();
	waitForTArm();

	startTDrivePID(300);
	waitForTDrive();
	startTDrivePID(70);
	waitForTDrive();
	stopTask(tClawPIDControl);
	stopTask(tArmConePIDControl);

	grab(127);
	wait1Msec(550);
	grab(50);
	startTArmConePID(HIGH_CARRY_ARM_POTENTIOMETER_VALUE + 250, true);

	if (autonomousSide == SIDE_RED) startTGyroPID(26);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(-26);
	waitForTGyroPID();

	startTDrivePID(100);
	wait1Msec(200);
	waitForTDrive();

	startTDrivePID(500);
	waitForTDrive();

	stopTask(tArmConePIDControl);
	setArmMotorPower(-40);
	wait1Msec(500);
	setArmMotorPower(0);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE);

	startTDrivePID(-200);
	waitForTDrive();

	}
	else if ( (*selectedProgram).id == menuItemAuton5P.id)
	{
	startTDrivePID(200);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 400, true);
	wait1Msec(200);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 37, false);
	waitForTClaw();
	stopTask(tArmConePIDControl);

	startTKeepArmDown();
	waitForTArm();
	waitForTDrive();

	startTDrivePID(1200);
	waitForTDrive();

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	stopAllTPID();
	grab(127);
	wait1Msec(300);
	grab(40);
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, true);
	if (autonomousSide == SIDE_BLUE) startTGyroPID(0);
	else if (autonomousSide == SIDE_RED) startTGyroPID(0);
	waitForTArm();
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);
	stopTask(tGyroPIDControl);

	startTDrivePID(-900);
	waitForTDrive();

	if (autonomousSide == SIDE_BLUE) startTGyroPID(-190);
	else if (autonomousSide == SIDE_RED) startTGyroPID(190);
	waitForTGyroPID();

	startTDrivePID(450);
	waitForTDrive();

	stopTask(tArmMoGoPIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 100, true);
	waitForTClaw();

	setDriveMotorPower(-127);
	wait1Msec(1000);
	setDriveMotorPower(0);
	}
	else if ( (*selectedProgram).id == menuItemAuton10P.id)
	{
	startTDrivePID(600);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 400, true);
	wait1Msec(200);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 37, false);
	waitForTClaw();
	stopTask(tArmConePIDControl);

	startTKeepArmDown();
	waitForTArm();
	waitForTDrive();

	startTDrivePID(800);
	waitForTDrive();

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	stopAllTPID();
	grab(127);
	wait1Msec(300);
	grab(40);
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, true);
	if (autonomousSide == SIDE_BLUE) startTGyroPID(5);
	else if (autonomousSide == SIDE_RED) startTGyroPID(-5);
	waitForTArm();
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);
	stopTask(tGyroPIDControl);

	startTDrivePID(-900);
	waitForTDrive();

	if (autonomousSide == SIDE_BLUE) startTGyroPID(-180);
	else if (autonomousSide == SIDE_RED) startTGyroPID(180);
	waitForTGyroPID();

	startTDrivePID(800);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(225);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(-225);
	waitForTGyroPID();

	startTDrivePID(400);
	waitForTDrive();

	stopTask(tArmConePIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE, true);
	waitForTClaw();

	setDriveMotorPower(-127, -127);
	wait1Msec(600);
	setDriveMotorPower(0);
	}
	else if ( (*selectedProgram).id == menuItemProgSkills1.id )
	{
	startTDrivePID(600);

	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE + 400, true);
	wait1Msec(200);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 37, false);
	waitForTClaw();
	stopTask(tArmConePIDControl);

	startTKeepArmDown();
	waitForTArm();
	waitForTDrive();

	startTDrivePID(800);
	waitForTDrive();

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	stopAllTPID();
	grab(127);
	wait1Msec(300);
	grab(40);
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, true);
	if (autonomousSide == SIDE_BLUE) startTGyroPID(5);
	else if (autonomousSide == SIDE_RED) startTGyroPID(-5);
	waitForTArm();
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);
	stopTask(tGyroPIDControl);

	startTDrivePID(-1500);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-32);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(32);
	waitForTGyroPID();

	startTDrivePID(-650);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-135);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(135);
	waitForTGyroPID();

	setDriveMotorPower(127, 127);
	wait1Msec(1300);

	stopTask(tArmMoGoPIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE, true);
	waitForTClaw();

	startTDrivePID(-400);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 600);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(0);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(0);
	startTArmConePID(CLAW_HALF_POTENTIOMETER_VALUE + 300);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE);
	waitForTGyroPID();

	stopTask(tArmConePIDControl);
	startTKeepArmDown();
	startTDrivePID(1000);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(90);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(-90);
	waitForTGyroPID();

	startTDrivePID(200);
	waitForTDrive();

	wait1Msec(300);

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	stopTask(tClawPIDControl);
	grab(127);
	wait1Msec(500);
	grab(35);

	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, true);
	startTDrivePID(-400);
	waitForTDrive();
	waitForTArm();
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);

	if (autonomousSide == SIDE_RED) startTGyroPID(0);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(0);
	waitForTGyroPID();

	startTDrivePID(-800);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-135);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(135);
	waitForTGyroPID();

	startTDrivePID(400);
	waitForTDrive();

	stopTask(tArmMoGoPIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE, true);
	waitForTClaw();

	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 200);
	startTDrivePID(-100);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(-45);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(45);
	waitForTGyroPID();

	startTDrivePID(-500);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(45);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(-45);
	startTKeepArmDown();
	waitForTGyroPID();

	startTDrivePID(900);
	waitForTDrive();

	setDriveMotorPower(127);
	wait1Msec(100);
	setDriveMotorPower(0);

	grab(127);
	wait1Msec(400);
	grab(35);

	startTDrivePID(-500);
	startTArmMoGoPID(LOW_CARRY_ARM_POTENTIOMETER_VALUE - 150, false);
	waitForTDrive();

	if (autonomousSide == SIDE_RED) startTGyroPID(225);
	else if (autonomousSide == SIDE_BLUE) startTGyroPID(-225);
	waitForTGyroPID();

	startTDrivePID(300);
	waitForTDrive();

	stopTask(tArmMoGoPIDControl);
	setArmMotorPower(0);
	setDriveMotorPower(0);
	startTClawPID(CLAW_OPEN_POTENTIOMETER_VALUE, true);
	waitForTClaw();

	startTDrivePID(-400);
	startTArmConePID(MIN_ARM_POTENTIOMETER_VALUE + 600);
	waitForTDrive();

	}
	if (!isCompetitionMode)
	{
	selectedProgram = &menuItemUserControl;
	stopTasks();
	startTask(usercontrol);
	} */
}



















/*---------------------------------------------------------------------------*/
/*							PID Mode Task									 */
/*---------------------------------------------------------------------------*/


task PIDMode()
{
	if ( (*selectedProgram).id == menuItemPIDDrive.id)
	{
		int goalPoint = 0;
		while (true)
		{
			goalPoint = (1 + random(15)) * 100;
			SensorValue[LED] = 1;
			drivePIDControl(goalPoint);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			drivePIDControl(-goalPoint);
			SensorValue[LED] = 0;
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDGyro.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			gyroPIDControl( (-36 + random(72)) * 100);
			SensorValue[LED] = 0;
			wait1Msec(1500);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDArm.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			armPIDControl(ARM_POTENTIOMETER_MIN_VALUE + random(ARM_POTENTIOMETER_MAX_VALUE), WAIT);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			armPIDControl(ARM_POTENTIOMETER_MIN_VALUE + random(ARM_POTENTIOMETER_MAX_VALUE), WAIT);
			SensorValue[LED] = 0;
			wait1Msec(1000);

			while (getArmSensorValue() > ARM_POTENTIOMETER_MIN_VALUE) { setArmMotorPower(-60); }
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDMini4Bar.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			mini4BarExtend();
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			mini4BarRetract();
			SensorValue[LED] = 0;
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDMoGoLift.id)
	{
		while (true)
		{
			SensorValue[LED] = 1;
			moGoExtend();
			SensorValue[LED] = 0;
			wait1Msec(1000);

			SensorValue[LED] = 1;
			moGoRetract();
			SensorValue[LED] = 0;
			wait1Msec(1000);
		}
	}
	else if ( (*selectedProgram).id == menuItemPIDCustom.id)
	{

	}
}



























int sensors[] = {
	/* Port 1 */			encoderArms,
	/* Port 2 */			encoderDriveRight,
	/* Port 3 */			encoderArms,
	/* Port 4 */			encoderArms,
	/* Port 5 */			potentiometerClawLeft,
	/* Port 6 */			potentiometerClawRight,
	/* Port 7 */			encoderArms,
	/* Port 8 */			encoderArms,
	/* Port 9 */			encoderDriveLeft,
	/* Port 10 */			encoderArms
};

//direction each motor should go when applied positive power (1 = positive, -1 = negative)
int directions[] = {
	/* Port 1 */			-1,
	/* Port 2 */			-1,
	/* Port 3 */			-1,
	/* Port 4 */			-1,
	/* Port 5 */			-1,
	/* Port 6 */			-1,
	/* Port 7 */			-1,
	/* Port 8 */			-1,
	/* Port 9 */			-1,
	/* Port 10 */			-1,
};


int motorPorts[] = { port1, port2, port3, port4, port5, port6, port7, port8, port9, port10 };
int lastSensorValue, motorPointer;

void nextMotor()
{
	if (motorPointer < 9) motorPointer++;
	else motorPointer = 0;
}

void previousMotor()
{
	if (motorPointer > 0) motorPointer--;
	else motorPointer = 9;
}

task manualCheck()
{
	displayLCDCenteredString(0, "Manual Check");
	string sMotorNum = "";
	string LCDLine = "";
	while (true)
	{
		sprintf(sMotorNum, "%2.0f%c", motorPointer + 1);
		LCDLine = "Port";
		LCDLine += sMotorNum;
		LCDLine += ": ";

		if (!isJoystickLCDMode())
		{
			if (motor[motorPorts[motorPointer]] == 127) LCDLine += "127";
			else if (motor[motorPorts[motorPointer]] == -127) LCDLine += "-127";
			else if (motor[motorPorts[motorPointer]] == 0) LCDLine += "0";

			displayLCDCenteredString(1, LCDLine);

			if (vexRT[btnNextMotor] == 1)
			{
				while (vexRT[btnNextMotor] == 1) { }
				nextMotor();
			}
			else if (vexRT[btnPreviousMotor] == 1)
			{
				while (vexRT[btnPreviousMotor] == 1) { }
				previousMotor();
			}
			else if (vexRT[btnPositivePower] == 1) motor[motorPorts[motorPointer]] = 127;
			else if (vexRT[btnNegativePower] == 1) motor[motorPorts[motorPointer]] = -127;
			else if (vexRT[btnStopMotor] == 1) motor[motorPorts[motorPointer]] = 0;
			else if (vexRT[btnAllMotorsOff] == 1) allMotorsOff();
		}
	}
}

task selfCheck()
{
	int passTable[10];
	bool hasTestPassed = true;
	string sMotorNum;
	displayLCDCenteredString(0, "Starting Test...");
	clearLCDLine(1);
	wait1Msec(2000);

	string LCDLine = "";

	for (int i = 0; i < 10; i++)
	{
		sMotorNum = "";
		sprintf(sMotorNum, "%2.0f%c", i + 1);
		LCDLine = "Testing Port ";
		LCDLine += sMotorNum;
		displayLCDCenteredString(0, LCDLine);
		displayLCDCenteredString(1, "Start?");

		waitForLCDButtonRelease();

		while (nLCDButtons != LCDCenterButton && vexRT[btnJoyLCDSelect] == 0) { }
		displayLCDCenteredString(1, "Please Wait...");

		bool hasPassed = false;
		lastSensorValue = SensorValue[sensors[i]];

		motor[i] = motorPower;
		wait1Msec(10);
		clearTimer(T1);

		int newSensorValue;
		int errorBounds;

		if (SensorType[sensors[i]] == sensorPotentiometer) errorBounds = potentiometerErrorBounds;
		else if (SensorType[sensors[i]] == sensorQuadEncoder) errorBounds = encoderErrorBounds;

		while (time1[T1] < testDuration)
		{
			newSensorValue = SensorValue[sensors[i]];
			if (newSensorValue - lastSensorValue != 0)
			{
				if (abs(newSensorValue - lastSensorValue) > errorBounds)
				{
					if ( (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue)) == directions[i])
					{
						hasPassed = true;
						break;
					}
					else if ( (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue)) * (-1) == directions[i] && time1[T1] > 500 )
					{
						hasPassed = false;
						break;
					}
				}
			}
		}

		int direction = 0;
		if (abs(newSensorValue - lastSensorValue) > errorBounds) direction = (newSensorValue - lastSensorValue / abs(newSensorValue - lastSensorValue));
		if (direction == directions[i]) passTable[i] = 1;
		else if (direction * (-1) == directions[i]) passTable = -1;
		else if (direction == 0) passTable[i] = 0;

		motor[i] = 0;

		if (!hasPassed)
		{
			LCDLine = "Port ";
			LCDLine += sMotorNum;
			LCDLine += " Failed";
			displayLCDCenteredString(0, LCDLine);

			if (passTable[i] == -1) displayLCDCenteredString(1, "Cause: Inversion");
			else if (passTable[i] == 0) displayLCDCenteredString(1, "Cause: Idle");
			hasTestPassed = false;
			wait1Msec(2000);

			displayLCDCenteredString(0, "Continuing In");
			displayLCDCenteredString(1, "Retry?");
			clearTimer(T1);
			while (time1[T1] < 3000)
			{
				LCDLine = "";
				sprintf(LCDLine, "%1.0f%c", (3 - (time1[T1] / 1000) ));
				displayLCDString(0, 15, LCDLine);

				if (nLCDButtons == LCDCenterButton || vexRT[btnJoyLCDSelect] == 1)
				{
					i--;
					break;
				}
			}
		}
		else
		{
			LCDLine = "Port ";
			LCDLine += sMotorNum;
			displayLCDCenteredString(0, LCDLine);
			displayLCDCenteredString(1, "Is Functional");
			wait1Msec(2000);
		}
	}

	displayLCDCenteredString(0, "Summary");
	wait1Msec(2000);
	for (int i = 0; i < 10; i++)
	{
		sMotorNum = "";
		sprintf(sMotorNum, "%2.0f%c", i + 1);
		LCDLine = "Port ";
		LCDLine += sMotorNum;
		if (passTable[i] != 1) LCDLine += " Failed";
		displayLCDCenteredString(0, LCDLine);

		if (passTable[i] == -1) displayLCDCenteredString(1, "Cause: Inversion");
		else if (passTable[i] == 0) displayLCDCenteredString(1, "Cause: Idle");
		else displayLCDCenteredString(1, "Is Functional");
		wait1Msec(2000);
	}

	selectedProgram = -1;
	stopTask(loadLCDScreen);
	startTask(loadLCDScreen);

task MotorCheck()
{

}
















































/*---------------------------------------------------------------------------*/
/*							User Control Task								 */
/*---------------------------------------------------------------------------*/




bool lockControls = true;
bool areSensorsOverridden = false;
bool isArmReadyMacroActive = false;


int SlewRate(int lastPower, int newPower) // Prevent large accelerations by reducing speed change if greater than MAX_SPEED_DIFFERENCE
{
	int speedDifference = lastPower - newPower;
	if (abs(speedDifference) < MAX_SPEED_DIFFERENCE)
	{
		return newPower;
	}
	else
	{
		return (lastPower - speedDifference * SLEW_RATE);
	}
}


task Arm()
{

	float pGain = (2.0/10.0);
	float iGain = (1.0/10000.0);
	float dGain = (0.0/10.0);

	while (true)
	{
		SetArmLimit();
		if (!lockControls && !isJoystickLCDMode())
		{
			/* Allow joystick control of arm if less than upper limit of sensors are overriden */
			if ( !isArmReadyMacroActive && (areSensorsOverridden || abs(vexRT[JOY_ARM]) > ARM_JOYSTICK_DEADZONE) )
			{
				while ( !isArmReadyMacroActive && (areSensorsOverridden || abs(vexRT[JOY_ARM]) > ARM_JOYSTICK_DEADZONE) )
				{
					SetArmLimit();
					setArmMotorPower(vexRT[JOY_ARM]);
				}
				setArmMotorPower(0);
				SetArmLimit();
			}
			/* If PID button is pressed, bring arm to carry value */
			else if (vexRT[BTN_ARM_HIGH_GOAL_PID] == 1 && !isArmReadyMacroActive)
			{
				while (vexRT[BTN_ARM_HIGH_GOAL_PID] == 1) { }
				int errorSum = 0;
				short goalPoint = ARM_POTENTIOMETER_HIGH_GOAL_VALUE * ARM_POTENTIOMETER_MULTIPLIER;
				int error = goalPoint - getArmSensorValue();
				int errorDifference = 0;
				int lastMotorPower = 0;
				int newPower = 0;

				/* Stay in PID mode until user uses joystick */
				while (abs(vexRT[JOY_ARM]) < ARM_JOYSTICK_DEADZONE && vexRT[BTN_ARM_HIGH_GOAL_PID] == 0 && !isArmReadyMacroActive)
				{
					errorDifference = error - (goalPoint - getArmSensorValue());
					error = goalPoint - getArmSensorValue();
					errorSum = errorSum + error;
					lastMotorPower = newPower;

					/* Prevent wind-up. Set max integral gain to full power. */
					if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
					else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

					newPower = error * pGain + errorSum * iGain - dGain * errorDifference;
					setArmMotorPower(newPower);
					wait1Msec(50);
				}
			}
		}
	}
}

short axisX;
short axisY;

task Drive()
{

	float a = (0.00022419);
	float ax = (0.000053321);
	float h = (-48.851);
	short x = 0, y = 0;

	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			/* Drive if joystick is greater than deadzone */
			if (abs(vexRT[JOY_DRIVE_X]) > DRIVE_JOYSTICK_DEADZONE || abs(vexRT[JOY_DRIVE_Y]) > DRIVE_JOYSTICK_DEADZONE)
			{
				x = vexRT[Ch2];
				y = vexRT[Ch1];
				axisY = a * pow(vexRT[Ch2] - (h * (vexRT[Ch2] / (-abs(vexRT[Ch2] + 0.1)))), 3) + (20 * (vexRT[Ch2] / (abs(vexRT[Ch2] + 0.1))));
				axisX = ax * pow(vexRT[Ch1] - (2 * (vexRT[Ch1] / (-abs(vexRT[Ch1] + 0.1)))), 3) + (20 * (vexRT[Ch1] / (abs(vexRT[Ch1] + 0.1))));

				setDriveMotorPower( SlewRate(motor[motorDriveLeftFront], axisY + axisX), SlewRate(motor[motorDriveRightFront], axisY - axisX) );
			}
			else setDriveMotorPower( SlewRate(motor[motorDriveLeftFront], 0), SlewRate(motor[motorDriveRightFront], 0) );
		}
		wait1Msec(25);
	}
}



void userMini4BarPControl(short goalPoint, WaitForAction stopWhenMet)
{
	float pGain = 2.0;

	goalPoint *= MINI_4_BAR_POTENTIOMETER_MULTIPLIER;

	bool isButtonReleased = false;
	int error = goalPoint * MINI_4_BAR_POTENTIOMETER_MULTIPLIER - getMini4BarSensorValue();

	while ( ( (stopWhenMet == WAIT && abs(error) > 30) || (stopWhenMet == WAIT_NONE) ) && vexRT[BTN_READY_ARM_MACRO] == 0 && vexRT[BTN_MINI_4_BAR_EXTEND_MANUAL] == 0 && vexRT[BTN_MINI_4_BAR_RETRACT_MANUAL] == 0 && ( (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 1 && !isButtonReleased) || vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 0 && isButtonReleased))
	{
		if (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 0) isButtonReleased = true;

		error = goalPoint * MINI_4_BAR_POTENTIOMETER_MULTIPLIER - getMini4BarSensorValue();
		setMini4BarMotorPower(error * pGain);
	}
	setMini4BarMotorPower(0);
}


task Goliath()
{
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[BTN_GOLIATH_REVERSE] == 1)
			{
				while (vexRT[BTN_GOLIATH_REVERSE] == 1)
				{
					setGoliathMotorPower(-50);
				}
				setGoliathMotorPower(50);
			}
		}
	}
}

task Mini4Bar()
{
	State currentState = STATE_RETRACTED;
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 1)
			{
				while (vexRT[BTN_MINI_4_BAR_TOGGLE_AUTO] == 1) { }
				currentState = (currentState == STATE_RETRACTED) ? STATE_EXTENDED : STATE_RETRACTED;
			}
			else if (vexRT[BTN_SENSOR_OVERRIDE] == 1)
			{
				while (vexRT[BTN_SENSOR_OVERRIDE] == 1) { }
				areSensorsOverridden = !areSensorsOverridden;
			}
			else if (vexRT[BTN_READY_ARM_MACRO] == 1)
			{
				isArmReadyMacroActive = true;
				userMini4BarPControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT);

				while (getArmSensorValue() > ARM_POTENTIOMETER_CONE_HEIGHT_VALUE * ARM_POTENTIOMETER_MULTIPLIER && !areSensorsOverridden) setArmMotorPower(-127);
				setArmMotorPower(0);
				isArmReadyMacroActive = false;
			}

			if (!areSensorsOverridden)
			{
				if (currentState == STATE_RETRACTED)
				{
					userMini4BarPControl(MINI_4_BAR_POTENTIOMETER_RETRACTED_VALUE, WAIT_NONE);
				}
				else if (currentState == STATE_EXTENDED)
				{
					userMini4BarPControl(MINI_4_BAR_POTENTIOMETER_EXTENDED_VALUE, WAIT_NONE);
				}
			}
			else if (areSensorsOverridden)
			{
				if (vexRT[BTN_MINI_4_BAR_EXTEND_MANUAL] == 1)
				{
					while (vexRT[BTN_MINI_4_BAR_EXTEND_MANUAL] == 1) setMini4BarMotorPower(127);
					setMini4BarMotorPower(0);
				}
				else if (vexRT[BTN_MINI_4_BAR_RETRACT_MANUAL] == 1)
				{
					while (vexRT[BTN_MINI_4_BAR_RETRACT_MANUAL] == 1) setMini4BarMotorPower(-127);
					setMini4BarMotorPower(0);
				}
			}
		}
	}
}



task MoGoLift()
{
	State currentState = STATE_RETRACTED;
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 1)
			{
				while (vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 1) { }
				currentState = (currentState == STATE_RETRACTED) ? STATE_EXTENDED : STATE_RETRACTED;
			}


			if (!areSensorsOverridden)
			{
				if (currentState == STATE_RETRACTED)
				{
					while (getMoGoLiftSensorValue() > MOGO_LIFT_POTENTIOMETER_RETRACTED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER)
					{
						setMoGoLiftMotorPower(-127);
					}
					setMoGoLiftMotorPower(0);
				}
				else if (currentState == STATE_EXTENDED)
				{
					float dGain = 2.0;

					int error = MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue();
					int errorDifference = 0;

					while (getMoGoLiftSensorValue() > MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER && !areSensorsOverridden && vexRT[BTN_MOGO_LIFT_TOGGLE_AUTO] == 0)
					{
						errorDifference = error - (MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue());
						error = MOGO_LIFT_POTENTIOMETER_EXTENDED_VALUE * MOGO_LIFT_POTENTIOMETER_MULTIPLIER - getMoGoLiftSensorValue();
						setMoGoLiftMotorPower(50 - dGain * abs(errorDifference) );
					}
					setMoGoLiftMotorPower(0);
				}
			}
			else if (areSensorsOverridden)
			{
				if (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1)
				{
					while (vexRT[BTN_MOGO_LIFT_EXTEND_MANUAL] == 1) setMoGoLiftMotorPower(127);
					setMoGoLiftMotorPower(0);
				}
				else if (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1)
				{
					while (vexRT[BTN_MOGO_LIFT_RETRACT_MANUAL] == 1) setMoGoLiftMotorPower(-127);
					setMoGoLiftMotorPower(0);
				}
			}
		}
	}
}


/* Safety control lock to prevent any user control when lock is enabled */
task ControlLock()
{
	while (true)
	{
		if (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1 && lockControls)
		{
			while (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1) wait1Msec(10);
			lockControls = false;
		}
		else if (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1 && !lockControls)
		{
			while (vexRT[BTN_CONTROL_LOCK_1] == 1 && vexRT[BTN_CONTROL_LOCK_2] == 1) wait1Msec(10);
			lockControls = true;
		}
	}
}




/* Main user control task */
task usercontrol()
{
	if (IS_ARM_ENABLED) startTask(Arm);
	if (IS_DRIVE_ENABLED) startTask(Drive);
	if (IS_GOLIATH_ENABLED) startTask(Goliath);
	if (IS_MINI_4_BAR_ENABLED) startTask(Mini4Bar);
	if (IS_MOGO_LIFT_ENABLED) startTask(MoGoLift);
	if (IS_CONTROL_LOCK_ENABLED) startTask(ControlLock);
	else lockControls = false;

	if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);

	if (isLCDEnabled)
	{
		displayLCDCenteredString(0, "Daud-_-Jaan");
		displayLCDCenteredString(1, "User Control");
	}
}


/* Start up program based on currently selected program and direction */
void startUp()
{
	stopTasks();
	allMotorsOff();

	string programName = (*selectedProgram).name;
	if ((*selectedProgram).isDirectional)
	{
		if (autonomousSide == SIDE_LEFT) programName += "L";
		else if (autonomousSide == SIDE_RIGHT) programName += "R";

		if (autonomousColor == COLOR_BLUE) programName += "B";
		else if (autonomousColor == COLOR_RED) programName += "R";
	}

	if ((*selectedProgram).id == menuItemUserControl.id) startTask(usercontrol);
	else if ((*selectedProgram).idx < SCREEN_LIST_PID_LENGTH - 1 && (*screenListPID[ (*selectedProgram).idx ]).id == (*selectedProgram).id)
	{
		/* Countdown if autonomous is selected */
		programName += " PID";
		displayLCDCenteredString(0, programName);
		clearLCDLine(1);
		displayLCDString(1, 2, "Starts In 3");
		wait1Msec(1000);
		displayLCDString(1, 12, "2");
		wait1Msec(1000);
		displayLCDString(1, 12, "1");
		wait1Msec(1000);

		startTask(PIDMode);
	}
	else if ((*selectedProgram).idx < SCREEN_LIST_AUTON_LENGTH - 1 && (*screenListAuton[ (*selectedProgram).idx ]).id == (*selectedProgram).id )
	{
		/* Countdown if autonomous is selected */
		displayLCDCenteredString(0, programName);
		clearLCDLine(1);
		displayLCDString(1, 2, "Starts In 3");
		wait1Msec(1000);
		displayLCDString(1, 12, "2");
		wait1Msec(1000);
		displayLCDString(1, 12, "1");
		wait1Msec(1000);

		startTask(autonomous);
	}
}












task playMissionImpossibleMusic()
{
	//        100 = Tempo
	//          6 = Default octave
	//    Quarter = Default note length
	//        10% = Break between notes
	//
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
	playTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
	playTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
	playTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))

}









/* Stop all non-vital tasks */
void stopTasks()
{
	stopTask(autonomous);
	stopTask(Arm);
	stopTask(Drive);
	stopTask(Goliath);
	stopTask(ControlLock);
	stopTask(usercontrol);
	stopTask(PIDMode);
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tMoGoLift);
	stopTask(tMini4Bar);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	stopTask(tKeepArmDown);
}
