#pragma config(Sensor, in2,   	gyro,           sensorGyro)
#pragma config(Sensor, in1,    	secondaryBattery, sensorAnalog)
#pragma config(Sensor, in3,    	potentiometerClawLeft, sensorPotentiometer)
#pragma config(Sensor, in4,   	potentiometerClawRight, sensorPotentiometer)
#pragma config(Sensor, dgtl5,  	limitSwitchArms1, sensorTouch)
#pragma config(Sensor, dgtl6,  	limitSwitchArms2, sensorTouch)
#pragma config(Sensor, dgtl7,  	encoderArms,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11,  encoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl9, 	encoderDriveRight, sensorQuadEncoder)
#pragma config(Motor,  port1,           motorClawLeft,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           motorArmRight,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           motorArmLeft,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motorDriveRight1,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           motorDriveRight2,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           motorArmRightMiddle,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           motorArmLeftMiddle,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           motorDriveLeft2,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           motorDriveLeft1,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          motorClawRight,      tmotorServoContinuousRotation, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard          `     !!*//

//!IMPORTANT -> Comment out this line to disable competition mode
#define competitionEnabled


#define isLCDEnabled					true
#define LCDLeftButton					1
#define LCDCenterButton					2
#define LCDRightButton					4
#define LCDSelectionScreenTimeoutMs		10000

typedef struct {
	short id;
	string name;
	string line2;
	bool isDirectional;
} menuItem;




//main screen menu items
menuItem menuItemUserControl, menuItemPIDMode, menuItemSwitchCompetitionMode, menuItemGoToAuton, menuItemResetGyro, menuItemBatteryLevel, menuItemCurrentProgram;
//autonomous menu items
menuItem menuItemAutonGoBack, menuItemAutonCO, menuItemAutonS, menuItemAutonB, menuItemAutonSWC, menuItemAutonF, menuItemAutonSRT, menuItemAutonP, menuItemAutonNone, menuItemProgSkills1, menuItemProgSkills2;
//direction menu items
menuItem menuItemDirectionGoBack, menuItemDirectionL, menuItemDirectionR;

#define SCREEN_LIST_MAIN_LENGTH	7
#define SCREEN_LIST_AUTON_LENGTH 12
#define SCREEN_LIST_DIRECTIONS_LENGTH 3
menuItem screenListMain[SCREEN_LIST_MAIN_LENGTH];
menuItem screenListAuton[SCREEN_LIST_AUTON_LENGTH];
menuItem screenListDirections[SCREEN_LIST_DIRECTIONS_LENGTH];

menuItem *currentMenu = &screenListMain;

void populateMenuItems() {
	byte i = 0;

	menuItemUserControl.name = "User Control";
	menuItemUserControl.id = i;
	screenListMain[i++] = menuItemUserControl;

	menuItemPIDMode.name = "PID Mode";
	menuItemPIDMode.id = i;
	screenListMain[i++] = menuItemPIDMode;

	menuItemSwitchCompetitionMode.name = "Switch Comp. Mode";
	menuItemSwitchCompetitionMode.id = i;
	screenListMain[i++] = menuItemSwitchCompetitionMode;

	menuItemGoToAuton.name = "Go To Autonomous";
	menuItemGoToAuton.id = i;
	screenListMain[i++] = menuItemGoToAuton;

	menuItemResetGyro.name = "Reset Gyro";
	menuItemResetGyro.id = i;
	screenListMain[i++] = menuItemResetGyro;

	menuItemBatteryLevel.name = "Battery Level";
	menuItemBatteryLevel.id = i;
	screenListMain[i++] = menuItemBatteryLevel;

	menuItemCurrentProgram.name = "Current Program";
	menuItemCurrentProgram.id = i;
	screenListMain[i++] = menuItemCurrentProgram;

	i = 0;

	menuItemAutonGoBack.name = "Go Back";
	menuItemAutonGoBack.id = i;
	screenListAuton[i++] = menuItemAutonGoBack;

	menuItemAutonCO.name = "AutonomousCO";
	menuItemAutonCO.id = i;
	menuItemAutonCO.isDirectional = true;
	screenListAuton[i++] = menuItemAutonCO;

	menuItemAutonS.name = "AutonomousS";
	menuItemAutonS.id = i;
	screenListAuton[i++] = menuItemAutonS;

	menuItemAutonB.name = "AutonomousB";
	menuItemAutonB.id = i;
	menuItemAutonB.isDirectional = true;
	screenListAuton[i++] = menuItemAutonB;

	menuItemAutonSWC.name = "AutonomousSWC";
	menuItemAutonSWC.id = i;
	menuItemAutonB.isDirectional = true;
	screenListAuton[i++] = menuItemAutonSWC;

	menuItemAutonF.name = "AutonomousF";
	menuItemAutonF.id = i;
	menuItemAutonF.isDirectional = true;
	screenListAuton[i++] = menuItemAutonF;

	menuItemAutonSRT.name = "AutonomousSRT";
	menuItemAutonSRT.id = i;
	screenListAuton[i++] = menuItemAutonSRT;

	menuItemAutonP.name = "AutonomousP";
	menuItemAutonP.id = i;
	screenListAuton[i++] = menuItemAutonP;

	menuItemAutonNone.name = "AutonomousNone";
	menuItemAutonNone.id = i;
	screenListAuton[i++] = menuItemAutonNone;

	menuItemProgSkills1.name = "Prog. Skills 1";
	menuItemProgSkills1.id = i;
	screenListAuton[i++] = menuItemProgSkills1;

	menuItemProgSkills2.name = "Prog. Skills 2";
	menuItemProgSkills2.id = i;
	screenListAuton[i++] = menuItemProgSkills2;

	i = 0;

	menuItemDirectionGoBack.name = "Go Back";
	menuItemDirectionGoBack.id = i;
	screenListDirections[i++] = menuItemDirectionGoBack;

	menuItemDirectionL.name = "L";
	menuItemDirectionL.id = i;
	screenListDirections[i++] = menuItemDirectionL;

	menuItemDirectionR.name = "R";
	menuItemDirectionR.id = i;
	screenListDirections[i++] = menuItemDirectionR;
}

#define LCDScreenUserControl			0
#define LCDScreenPIDMode				1
#define LCDScreenSwitchCompetitionMode	2
#define	LCDScreenGoToAutonomous			3
#define LCDScreenResetGyro				4
#define LCDScreenBatteryLevel			5
#define LCDScreenCurrentProgram			6

#define LCDScreenAutonomousGoBack		200
#define LCDScreenAutonomousCO			201
#define LCDScreenAutonomousS			202
#define LCDScreenAutonomousB			203
#define LCDScreenAutonomousSWC			204
#define	LCDScreenAutonomousF			205
#define	LCDScreenAutonomousSRT			206
#define	LCDScreenAutonomousP			207
#define LCDScreenAutonomousNone			208
#define LCDScreenProgSkills1			209
#define LCDScreenProgSkills2			210

#define LCDScreenDirectionGoBack		100
#define LCDScreenAutonomousL			101
#define LCDScreenAutonomousR			102

#define sideLeft	false
#define sideRight	true


#define isDriveEnabled			true
#define isPIDEnabled			false
#define isControlLockEnabled	false

#define btnJoyLCDSelect			Btn8D
#define btnJoyLCDPrevious		Btn8L
#define btnJoyLCDNext			Btn8R
#define btnControlLock1			Btn8U
#define btnControlLock2			Btn7U
#define btnClawManualClose		Btn8D
#define btnBlock				Btn6D
#define btnClawManualOpen		Btn5D
#define btnClawGrab 			Btn6U
#define btnClawOverride			Btn7U
#define btnClawHalfway			Btn5U
#define btnArmsManualRaise		Btn6U
#define btnResetArmSensor		Btn7L
#define btnSensitiveDrive		Btn8R
#define joyDriveX				Ch1
#define joyDriveY				Ch2
#define joyArms					Ch3
#define joyClaw					Ch4

#define driveJoystickDeadzone	20
#define armsJoystickDeadzone	20
#define clawJoystickDeadzone	20

#define isArmsEnabled					true
#define maxArmEncoderValue				1100
#define limitSwitchBounds				150
#define blockEncoderValue				1100
#define throwArmEncoderValue			700
#define	clawReleaseArmEncoderValue 		800
#define lowCarryArmEncoderValue			234
#define highCarryArmEncoderValue		750
#define isClawEnabled					true
#define closedClawPotentiometerValue	2460
#define openClawPotentiometerValue		1400
#define halfwayClawPotentiometerValue	2000
#define potentiometerClawLeftOffset		0
#define potentiometerClawRightOffset 	0

#define isSlewRateEnabled	true
#define maxSpeedDifference	20
#define slewRate			0.3

#define armsLowerSpeed		30
#define armsRaiseSpeed		127

#define gyroMultiplier		-1

#define passwordEnabled false

#define actionDrive 	0
#define actionArms 		1
#define actionClaw		2
#define actionClawLeft 	3
#define actionClawRight 4

#define startupLCDProgram	LCDScreenUserControl


#pragma platform(VEX2)
#pragma competitionControl(Competition)

void pre_auton();
task autonomous();
task usercontrol();

bool bStopTasksBetweenModes = true;
#if !defined(VEX2) && !defined(VEX)
#error "Switch to the VEX cortex platform"
#endif

void allMotorsOff();
void stopTasks();
bool isCompetitionMode = false;

task main()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
	displayNextLCDString("Startup");
	wait1Msec(2000);
	clearLCDLine(0);

	pre_auton();

	while (true)
	{
		if (isCompetitionMode)
		{
			// remain in this loop while the robot is disabled
			while (bIfiRobotDisabled)
			{
				while (true)
				{
					if (!bIfiRobotDisabled)
						break;
					wait1Msec(25);
				}
			}

			if (bIfiAutonomousMode)
			{
				startTask(autonomous);

				// Waiting for autonomous phase to end
				while (bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (!bVEXNETActive)
					{
						if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
							allMotorsOff();
					}
					wait1Msec(25);               // Waiting for autonomous phase to end
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}

			else
			{
				startTask(usercontrol);

				// Here we repeat loop waiting for user control to end and (optionally) start
				// of a new competition run
				while (!bIfiAutonomousMode && !bIfiRobotDisabled)
				{
					if (nVexRCReceiveState == vrNoXmiters) // the transmitters are powered off!!
						allMotorsOff();
					wait1Msec(25);
				}
				allMotorsOff();
				if(bStopTasksBetweenModes)
				{
					stopTasks();
				}
			}
		}
	}
}

void allMotorsOff()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
#if defined(VEX2)
	motor[port9] = 0;
	motor[port10] = 0;
#endif
}






/*---------------------------------------------------------------------------*/
/*													Pre-Autonomous Functions */
/*																			 */
/*	You may want to perform some actions before the competition starts.		 */
/*	Do them in the following function.	You must return from this function	 */
/*	or the autonomous and usercontrol tasks will not be started.	This	 */
/*	function is only called once after the cortex has been powered on and	 */
/*	not every time that the robot is disabled.															 */
/*---------------------------------------------------------------------------*/
void startUp();

task loadLCDScreen;
task usercontrol;
task PIDMode;


short selectedProgram;
short LCDScreenMin = LCDScreenGoToAutonomous;
short LCDScreenMax = LCDScreenBatteryLevel;
short LCDScreen = 0;
bool autonomousSide = sideLeft;
int LCDActiveTime = 0;

string LCDAction = "<     Start    >";


char* getProgramName(int programNum)
{
	switch (programNum)
	{
	case LCDScreenUserControl:
		return "User Control";
		break;

	case LCDScreenPIDMode:
		return "PID Mode";
		break;

	case LCDScreenAutonomousCO:
		return "AutonomousCO";
		break;

	case LCDScreenAutonomousS:
		return "AutonomousS";
		break;

	case LCDScreenAutonomousB:
		return "AutonomousB";
		break;

	case LCDScreenAutonomousSWC:
		return "AutonomousSWC";
		break;

	case LCDScreenProgSkills1:
		return "Prog. Skills 1";
		break;

	case LCDScreenProgSkills2:
		return "Prog. Skills 2";
		break;

	case LCDScreenAutonomousF:
		return "AutonomousF";
		break;

	case LCDScreenAutonomousSRT:
		return "AutonomousSRT";
		break;

	case LCDScreenAutonomousNone:
		return "Autonomous None";
		break;

	case LCDScreenAutonomousL:
		return "Autonomous Left";
		break;

	case LCDScreenAutonomousR:
		return "Autonomous Right";
		break;

	case LCDScreenAutonomousGoBack:
	case LCDScreenDirectionGoBack:
		return "Go Back";
		break;

	case LCDScreenBatteryLevel:
		return "Battery Level";
		break;

	case LCDScreenGoToAutonomous:
		return "Autonomous List";
		break;

	case LCDScreenResetGyro:
		return "Reset Gyro?";
		break;

	case LCDScreenSwitchCompetitionMode:
		return "Switch Mode?";
		break;
	}

	return "";
}


bool isJoystickLCDMode() {
	return (vexRT[Btn7R] == 1);
}


void waitForLCDButtonRelease()
{
	while (!(nLCDButtons == 0 && vexRT[btnJoyLCDPrevious] == 0 && vexRT[btnJoyLCDSelect] == 0 && vexRT[btnJoyLCDNext] == 0))
	{
		wait1Msec(10);
	}
}

bool isTaskActive()
{
	if (getTaskState(usercontrol) != taskStateStopped || getTaskState(autonomous) != taskStateStopped || getTaskState(PIDMode) != taskStateStopped)
		return true;

	return false;
}

void waitForLCDButtonPress()
{
	LCDActiveTime = 0;

	if (selectedProgram == -1 || !isTaskActive())
	{
		while ( nLCDButtons == 0 && vexRT[btnJoyLCDPrevious] == 0 && vexRT[btnJoyLCDSelect] == 0 && vexRT[btnJoyLCDNext] == 0)
		{
			wait1Msec(10);
			LCDActiveTime++;

			if (LCDActiveTime > LCDSelectionScreenTimeoutMs / 10)
			{
				break;
			}
		}
	}
	else
	{
		while (nLCDButtons == 0 && ( !isJoystickLCDMode() || (vexRT[btnJoyLCDPrevious] == 0 && vexRT[btnJoyLCDSelect] == 0 && vexRT[btnJoyLCDNext] == 0 ) ))
		{
			wait1Msec(10);
		}
	}
}



void LCDNextScreen()
{
	if (LCDScreen < LCDScreenMax) LCDScreen++;
	else LCDScreen = LCDScreenMin;
}

void LCDPreviousScreen()
{
	if (LCDScreen > LCDScreenMin) LCDScreen--;
	else LCDScreen = LCDScreenMax;
}


void displayBatteryLevelOnLCD()
{
	clearLCDLine(0);
	clearLCDLine(1);
	string mainBattery, backupBattery;

	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V');
	sprintf(backupBattery, "%1.2f%c", SensorValue[secondaryBattery] / 280.0, 'V');

	displayLCDString(0, 0, "Primary: ");
	displayNextLCDString(mainBattery);
	displayLCDString(1, 0, "Secondary: ");
	displayNextLCDString(backupBattery);
}

bool isSideDependent(int programNum)
{
	return (screenListAuton[programNum].isDirectional);
}

void displayProgram()
{
	string programName = currentMenu[LCDScreen].name;
	displayLCDCenteredString(0, currentMenu[LCDScreen].name);
	displayLCDCenteredString(1, LCDAction);


	if (currentMenu[LCDScreen] == menuItemBatteryLevel)
	{
		displayBatteryLevelOnLCD();
	}
	else if (currentMenu[LCDScreen] == menuItemCurrentProgram)
	{
		displayLCDCenteredString(0, "Balsdeep-_-Singh");
		displayLCDCenteredString(1, currentMenu[LCDScreen].name);
	}
	else if (currentMenu == screenListDirections && currentMenu[LCDScreen] == menuItemDirectionL || currentMenu[LCDScreen] == menuItemDirectionR)
	{
		programName = currentMenu[LCDScreen].name;
		if (currentMenu[LCDScreen] == menuItemDirectionL) programName += "L";
		else programName += "R";
		displayLCDCenteredString(0, programName);
	}
	else if (currentMenu[LCDScreen] == menuItemDirectionGoBack || currentMenu[LCDScreen] == menuItemAutonGoBack || currentMenu[LCDScreen] == menuItemGoToAuton || currentMenu[LCDScreen].isDirectional)
	{
		displayLCDCenteredString(1, "<    Select    >");
	}
	else if (currentMenu[LCDScreen] == menuItemResetGyro)
	{
		waitForLCDButtonRelease();
		string gyroValue;
		displayLCDString(1, 0, "< Reset (");
		while (nLCDButtons == 0 && vexRT[btnJoyLCDNext] == 0 && vexRT[btnJoyLCDPrevious] == 0 && vexRT[btnJoyLCDSelect] == 0)
		{
			sprintf(gyroValue, "%4.0f%c", SensorValue[gyro]);
			gyroValue += ")";
			displayLCDString(1, 9, gyroValue);
			displayLCDString(1, 15, ">");
		}
	}
	else if (currentMenu[LCDScreen] == menuItemSwitchCompetitionMode)
	{
		if (isCompetitionMode) displayLCDCenteredString(0, "Comp Mode Active");
		else displayLCDCenteredString(0, "Test Mode Active");
		displayLCDCenteredString(1, "< Switch  Mode >");
	}


	waitForLCDButtonPress();

	if (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[btnJoyLCDNext] == 1 && vexRT[btnJoyLCDPrevious] == 1))
	{
		while (nLCDButtons == LCDLeftButton + LCDRightButton || (vexRT[btnJoyLCDNext] == 1 && vexRT[btnJoyLCDPrevious] == 1))
		{
			displayBatteryLevelOnLCD();
		}
	}
	else if (nLCDButtons == LCDLeftButton || vexRT[btnJoyLCDPrevious] == 1)
	{
		waitForLCDButtonRelease();
		LCDPreviousScreen();
	}
	else if (nLCDButtons == LCDRightButton || vexRT[btnJoyLCDNext] == 1)
	{
		waitForLCDButtonRelease();
		LCDNextScreen();
	}
	else if ( (nLCDButtons == LCDCenterButton || vexRT[btnJoyLCDSelect] == 1) && currentMenu[LCDScreen] != menuItemBatteryLevel && currentMenu[LCDScreen] != menuItemCurrentProgram)
	{
		waitForLCDButtonRelease();
		if (currentMenu == screenListAuton && currentMenu[LCDScreen] != menuItemAutonGoBack)
		{
			selectedProgram = currentMenu[LCDScreen].id;
			currentMenu = &screenListDirections;
			LCDScreen = 0;
			LCDScreenMax = SCREEN_LIST_DIRECTIONS_LENGTH;
		}
		else if (currentMenu[LCDScreen] == menuItemDirectionGoBack || currentMenu[LCDScreen] == menuItemGoToAuton)
		{
			LCDScreen = 0;
			currentMenu = &screenListAuton;
			LCDScreenMax = SCREEN_LIST_AUTON_LENGTH;
		}
		else if (currentMenu[LCDScreen] == menuItemAutonGoBack)
		{
			LCDScreenMax = SCREEN_LIST_MAIN_LENGTH;
			if (isCompetitionMode)
			{
				currentMenu = &screenListMain;
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.id;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.id;
#endif
			}
			else LCDScreenMin = menuItemUserControl.id;
			LCDScreen = menuItemGoToAuton.id;
		}
		else if (currentMenu[LCDScreen] == menuItemResetGyro)
		{
			SensorValue[gyro] = 0;
			displayLCDCenteredString(0, "Gyro Reset!");
			clearLCDLine(1);
			wait1Msec(1000);
		}
		else if (currentMenu[LCDScreen] == menuItemSwitchCompetitionMode)
		{
			isCompetitionMode = !isCompetitionMode;
			if (!isCompetitionMode) LCDAction = "<     Start    >";
			else LCDAction = "<    Select    >";
			displayLCDCenteredString(0, "Mode Switched!");
			clearLCDLine(1);
			wait1Msec(1000);

			if (isCompetitionMode)
			{
				currentMenu = &screenListMain;
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.id;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.id;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.id;
				stopTasks();
				startUp();
			}
		}
		else
		{
			if (currentMenu[LCDScreen] ==  menuItemDirectionL) autonomousSide = sideLeft;
			else if (currentMenu[LCDScreen] ==  menuItemDirectionR) autonomousSide = sideRight;
			else selectedProgram = currentMenu[LCDScreen].id;

			LCDScreenMax = SCREEN_LIST_MAIN_LENGTH;
			LCDScreen = menuItemCurrentProgram.id;

			if (isCompetitionMode)
			{
				currentMenu = &screenListMain;
#ifdef competitionEnabled
				LCDScreenMin = menuItemGoToAuton.id;
#else
				LCDScreenMin = menuItemSwitchCompetitionMode.id;
#endif
			}
			else
			{
				LCDScreenMin = menuItemUserControl.id;
				stopTasks();
				startUp();
			}
		}
	}
}

task loadLCDScreen()
{
	while (true)
	{
		displayProgram();
	}
}



int waitForJoystickButtonPress()
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	int count = 0;
	int i = 0;
	int buttonPressed;

	while (true)
	{
		count = 0;
		for (i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1)
			{
				count++;
				buttonPressed = i;
			}
		}
		if (count == 1) return buttons[buttonPressed];
	}
}


void waitForJoystickButtonRelease()
{
	int buttons[12] = { Btn5D, Btn5U, Btn6D, Btn6U, Btn7U, Btn7D, Btn7R, Btn7L, Btn8R, Btn8D, Btn8U, Btn8L };
	bool buttonReleased = true;
	while (true)
	{
		buttonReleased = true;
		for (int i = 0; i < 12; i++)
		{
			if (vexRT[buttons[i]] == 1) buttonReleased = false;
		}
		if (buttonReleased == true) break;
	}
}

task playMissionImpossibleMusic()
{
	//        100 = Tempo
	//          6 = Default octave
	//    Quarter = Default note length
	//        10% = Break between notes
	//
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
	playTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
	playTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
	playTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))

}



void pre_auton()
{
	//startTask(playMissionImpossibleMusic);
	bStopTasksBetweenModes = true;
	populateMenuItems();
	stopTasks();

#ifdef competitionEnabled
	isCompetitionMode = true;
#endif

	if (isLCDEnabled)
	{
		selectedProgram = -1;
#ifndef competitionEnabled
		LCDScreenMin = menuItemUserControl.id;
#endif
		LCDScreen = 0;
		LCDScreenMax = menuItemBatteryLevel.id;
		bLCDBacklight = true;

		if (!isCompetitionMode)
		{
			LCDAction = "<     Start    >";
			selectedProgram = startupLCDProgram;
			LCDScreen = menuItemCurrentProgram.id;
			stopTask(loadLCDScreen);
			startTask(loadLCDScreen);
			stopTasks();
			startUp();
		}
		else LCDAction = "<    Select    >";

		displayLCDCenteredString(0, "So Balsdeep");
		displayLCDCenteredString(1, "You'll Blackout");
		wait1Msec(1500);
#ifndef competitionEnabled

		if (passwordEnabled)
		{
			bool correctPassword = false;
			int incorrectAttempts = 3;
			while (!correctPassword)
			{
				displayLCDCenteredString(0, "Enter Password");
				displayLCDCenteredString(1, "");
				int correctCode[5] = { Btn5D, Btn6U, Btn7D, Btn6U, Btn8R };
				int code[5];

				for (int i = 0; i < 5; i++)
				{
					waitForJoystickButtonPress();
					code[i] = waitForJoystickButtonPress();
					waitForJoystickButtonRelease();
					displayLCDString(1, 6 + i, "*");
				}

				correctPassword = true;

				for (int i = 0; i < 5; i++)
				{
					if (code[i] != correctCode[i]) correctPassword = false;
				}

				if (!correctPassword)
				{
					incorrectAttempts--;
					displayLCDCenteredString(0, "Wrong Password");
					displayLCDCenteredString(1, "**************");
					wait1Msec(1500);

					string attempts = "";
					sprintf(attempts, "%d", incorrectAttempts);
					attempts += " Attempts Left";
					displayLCDCenteredString(0, "You Have");
					displayLCDCenteredString(1, attempts);
					wait1Msec(1500);

					if (incorrectAttempts == 0)
					{
						displayLCDCenteredString(0, "Bye Bye");
						displayLCDCenteredString(1, "");
						wait1Msec(2000);
						stopAllTasks();
						stopTask(main);
						stopTask(loadLCDScreen);
					}
				}
			}
		}
#endif

		SensorValue[encoderArms] = 0;
		SensorValue[encoderDriveLeft] = 0;
		SensorValue[encoderDriveRight] = 0;
		SensorValue[gyro] = 0;
		startTask(loadLCDScreen);
	}
}

/*---------------------------------------------------------------------------*/
/*																																					 */
/*															Autonomous Task															 */
/*																																					 */
/*	This task is used to control your robot during the autonomous phase of	 */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/

void checkArmLimitSwitch()
{
	if (((SensorValue[encoderArms] < limitSwitchBounds) && (SensorValue[limitSwitchArms1] == 1 || SensorValue[limitSwitchArms2] == 1)) || SensorValue[encoderArms] < 0) SensorValue[encoderArms] = 0;
}

const float leftDriveMultiplier = (10.0/10.0);
const float rightDriveMultiplier = (10.0/10.0);

void aDrive(int leftMotorSpeed, int rightMotorSpeed)
{
	motor[motorDriveRight1] = rightMotorSpeed * rightDriveMultiplier;
	motor[motorDriveRight2] = rightMotorSpeed * rightDriveMultiplier;

	motor[motorDriveLeft1] = leftMotorSpeed * leftDriveMultiplier;
	motor[motorDriveLeft2] = leftMotorSpeed * leftDriveMultiplier;
}

void aDrive(int speed)
{
	motor[motorDriveRight1] = speed * rightDriveMultiplier;
	motor[motorDriveRight2] = speed * rightDriveMultiplier;

	motor[motorDriveLeft1] = speed * leftDriveMultiplier;
	motor[motorDriveLeft2] = speed * leftDriveMultiplier;
}

void aArms(int motorSpeed)
{
	motor[motorArmLeft] = motorSpeed;
	motor[motorArmLeftMiddle] = motorSpeed;

	motor[motorArmRight] = motorSpeed;
	motor[motorArmRightMiddle] = motorSpeed;
}


void aClaw(int leftMotorSpeed, int rightMotorSpeed)
{
	//motor[motorClawLeft] = leftMotorSpeed;
	//motor[motorClawRight] = rightMotorSpeed;
}


void aClawLeft(int motorSpeed)
{
	//motor[motorClawLeft] = motorSpeed;
}

void aClawRight(int motorSpeed)
{
	//motor[motorClawRight] = motorSpeed;
}

void aClaw(int motorSpeed)
{
	aClaw(motorSpeed, motorSpeed);
}



/*void resetDriveEncoders()
{
SensorValue[encoderDriveLeft] = 0;
SensorValue[encoderDriveRight] = 0;
}*/

bool autonomousReady = true;

void waitUntilReady()
{
	wait1Msec(10);
	while (!autonomousReady) { }
}

void actionTimed(char action, int time, int leftMotorSpeed, int rightMotorSpeed)
{
	autonomousReady = false;

	checkArmLimitSwitch();
	clearTimer(T1);
	if (action == actionDrive) aDrive(leftMotorSpeed, rightMotorSpeed);
	else if (action == actionArms) aArms(leftMotorSpeed);
	else if (action == actionClaw) aClaw(leftMotorSpeed);

	while (time1[T1] <= time) checkArmLimitSwitch();

	if (action == actionDrive) aDrive(0,0);
	else if (action == actionArms) aArms(0);
	else if (action == actionClaw) aClaw(0);

	autonomousReady = true;
}


void actionTimed(char action, int time, int motorSpeed)
{
	autonomousReady = false;

	checkArmLimitSwitch();
	clearTimer(T1);
	if (action == actionDrive) aDrive(motorSpeed, motorSpeed);
	else if (action == actionArms) aArms(motorSpeed);
	else if (action == actionClaw) aClaw(motorSpeed);

	while (time1[T1] <= time) checkArmLimitSwitch();

	if (action == actionDrive) aDrive(0,0);
	else if (action == actionArms) aArms(0);
	else if (action == actionClaw) aClaw(0);

	autonomousReady = true;
}


void actionUntilAtGoalPoint(char action, short goalPoint, int motorSpeed)
{
	autonomousReady = false;

	checkArmLimitSwitch();
	int referencePoint;

	if (action == actionDrive) referencePoint = SensorValue[encoderDriveLeft];
	else if (action == actionArms) referencePoint = SensorValue[encoderArms];
	else if (action == actionClaw) referencePoint = (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
	else if (action == actionClawLeft) referencePoint = (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
	else if (action == actionClawRight) referencePoint = (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset);

	if (referencePoint < goalPoint)
	{
		motorSpeed = abs(motorSpeed);
		if (action == actionDrive)
		{
			aDrive(motorSpeed, motorSpeed);
			while (SensorValue[encoderDriveLeft] < goalPoint) { }
		}
		else if (action == actionArms)
		{
			aArms(motorSpeed);
			while (SensorValue[encoderArms] < goalPoint)
			{
				checkArmLimitSwitch();
			}
		}
		else if (action == actionClaw)
		{
			if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint)
			{
				while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint)
				{
					if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint) aClawLeft(motorSpeed);
					else aClawLeft(0);
					if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint) aClawRight(motorSpeed * (-1));
					else aClawRight(0);
				}
			}
			else if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint)
			{
				while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint)
				{
					if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint) aClawLeft(motorSpeed);
					else aClawLeft(0);
					if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint) aClawRight(motorSpeed);
					else aClawRight(0);
				}
			}
		}
		else if (action == actionClawLeft)
		{
			aClawLeft(motorSpeed);
			while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint) { }
		}
		else if (action == actionClawRight)
		{
			aClawRight(motorSpeed);
			while ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint) { }
		}
	}
	else if (referencePoint > goalPoint)
	{
		motorSpeed = abs(motorSpeed) * (-1);
		if (action == actionDrive)
		{
			aDrive(motorSpeed, motorSpeed);
			while (SensorValue[encoderDriveLeft] > goalPoint) { }
		}
		else if (action == actionArms)
		{
			aArms(motorSpeed);
			while (SensorValue[encoderArms] > goalPoint)
			{
				checkArmLimitSwitch();
			}
		}
		else if (action == actionClaw)
		{
			if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint)
			{
				while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint)
				{
					if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint) aClawLeft(motorSpeed);
					else aClawLeft(0);
					if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint) aClawRight(motorSpeed);
					else aClawRight(0);
				}
			}
			else if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint)
			{
				while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint)
				{
					if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint) aClawLeft(motorSpeed);
					else aClawLeft(0);
					if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint) aClawRight(motorSpeed * (-1));
					else aClawRight(0);
				}
			}
		}
		else if (action == actionClawLeft)
		{
			aClawLeft(motorSpeed);
			while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint) { }
		}
		else if (action == actionClawRight)
		{
			aClawRight(motorSpeed);
			while ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint) { }
		}
	}

	if (action == actionDrive) aDrive(0,0);
	else if (action == actionArms) aArms(0);
	else if (action == actionClaw) aClaw(0);
	else if (action == actionClawLeft) aClawLeft(0);
	else if (action == actionClawRight) aClawRight(0);

	autonomousReady = true;
}


void actionUntilOverGoalPoint(char action, short goalPoint, int leftMotorSpeed, int rightMotorSpeed)
{
	autonomousReady = false;

	checkArmLimitSwitch();
	if (action == actionDrive)
	{
		SensorValue[encoderDriveLeft] = 0;
		aDrive(leftMotorSpeed, rightMotorSpeed);
		while (SensorValue[encoderDriveLeft] < goalPoint) { }
	}
	else if (action == actionArms)
	{
		aArms(leftMotorSpeed);
		while (SensorValue[encoderArms] < goalPoint)
		{
			checkArmLimitSwitch();
		}
	}
	else if (action == actionClaw)
	{
		while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint)
		{
			if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint) aClawLeft(leftMotorSpeed);
			else aClawLeft(0);
			if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint) aClawRight(rightMotorSpeed);
			else aClawRight(0);
		}
	}
	else if (action == actionClawLeft)
	{
		aClawLeft(leftMotorSpeed);
		while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < goalPoint) { }
	}
	else if (action == actionClawRight)
	{
		aClawRight(leftMotorSpeed);
		while ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < goalPoint) { }
	}


	if (action == actionDrive) aDrive(0,0);
	else if (action == actionArms) aArms(0);
	else if (action == actionClaw) aClaw(0);
	else if (action == actionClawLeft) aClawLeft(0);
	else if (action == actionClawRight) aClawRight(0);

	autonomousReady = true;
}


void actionUntilOverGoalPoint(char action, short goalPoint, int motorSpeed)
{
	actionUntilOverGoalPoint(action, goalPoint, motorSpeed, motorSpeed);
}


void actionUntilUnderGoalPoint(char action, short goalPoint, int leftMotorSpeed, int rightMotorSpeed)
{
	autonomousReady = false;

	checkArmLimitSwitch();
	if (action == actionDrive)
	{
		SensorValue[encoderDriveLeft] = 0;
		aDrive(leftMotorSpeed, rightMotorSpeed);
		while (SensorValue[encoderDriveLeft] > goalPoint) { }
	}
	else if (action == actionArms)
	{
		aArms(leftMotorSpeed);
		while (SensorValue[encoderArms] > goalPoint)
		{
			checkArmLimitSwitch();
		}
	}
	else if (action == actionClaw)
	{
		while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint || (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint)
		{
			if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint) aClawLeft(leftMotorSpeed);
			else aClawLeft(0);
			if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint) aClawRight(rightMotorSpeed);
			else aClawRight(0);
		}
	}
	else if (action == actionClawLeft)
	{
		aClawLeft(leftMotorSpeed);
		while ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) > goalPoint) { }
	}
	else if (action == actionClawRight)
	{
		aClawRight(leftMotorSpeed);
		while ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) > goalPoint) { }
	}

	if (action == actionDrive) aDrive(0,0);
	else if (action == actionArms) aArms(0);
	else if (action == actionClaw) aClaw(0);
	else if (action == actionClawLeft) aClawLeft(0);
	else if (action == actionClawRight) aClawRight(0);

	autonomousReady = true;
}

void actionUntilUnderGoalPoint(char action, short goalPoint, int motorSpeed)
{
	actionUntilUnderGoalPoint(action, goalPoint, motorSpeed, motorSpeed);
}


void drivePIDControl(short goalPoint)
{
	autonomousReady = false;

	float pGain = (127.0/2000.0);
	float iGain = (8.0/10000.0);
	float dGain = (1.0/1000.0);

	goalPoint = SensorValue[encoderDriveRight] + goalPoint;

	int error = goalPoint - SensorValue[encoderDriveRight];
	int errorDifference = 0;
	int newSpeed = 0;
	int minSpeed = 30;
	int errorSum = 0;

	while (abs(error) > 5)
	{
		errorDifference = error - (goalPoint - SensorValue[encoderDriveRight]);
		error = goalPoint - SensorValue[encoderDriveRight];
		errorSum += error;

		if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

		newSpeed = error * pGain + errorSum * iGain - errorDifference * dGain;

		if (newSpeed > -minSpeed && error < 0) newSpeed = -minSpeed;
		else if (newSpeed < minSpeed && error > 0) newSpeed = minSpeed;
		aDrive(newSpeed, newSpeed);

		wait1Msec(1);
	}
	aDrive(0,0);
	autonomousReady = true;
}


void gyroDrive(int power, int time, int deg)
{
	autonomousReady = false;

	deg *= 10;
	float pGain = (500.0/1000.0);
	int error = 0;

	clearTimer(T1);
	while (time1[T1] < time)
	{
		error = SensorValue[gyro] - deg;
		if (SensorValue[gyro] > deg)
		{
			aDrive( power - error * pGain, power );
		}
		else if (SensorValue[gyro] < deg)
		{
			aDrive( power, power - error * pGain );
		}
		else
		{
			aDrive(power);
		}
	}

	autonomousReady = true;
}



void gyroHang(short goalPoint)
{
	autonomousReady = false;

	float pGain = (127.0/1000.0);

	goalPoint = (goalPoint * 10);
	while (goalPoint > 3600) goalPoint -= 3600;
	while (goalPoint < -3600) goalPoint += 3600;
	int error = 0;

	float lastError = 0;
	error = SensorValue[gyro] - goalPoint;
	float newSpeed = 0;

	while (error != 0)
	{
		lastError = error;
		error = SensorValue[gyro] - goalPoint;
		newSpeed = error * pGain;
		if (lastError == error) pGain += (1.0/1000.0);
		else pGain = (127.0/1200.0);
		aDrive(newSpeed * (-1), newSpeed);
	}
	aDrive(0,0);

	autonomousReady = true;
}




void gyroFace(int degrees)
{
	autonomousReady = false;

	degrees *= gyroMultiplier;
	degrees *= 10;
	int undershoot = 160;
	//degrees = (SensorValue[gyro] - degrees * 10) / 10;
	int error = degrees - SensorValue[gyro];
	int left = 0, right = 0;
	if (degrees < 0){left = -1; right = 1;}
	else if (degrees > 0){left = 1; right = -1; }

	if (abs(error) > undershoot)
	{
		if (error > 0)
		{
			while (degrees - undershoot - SensorValue[gyro] > 0)
			{
				aDrive(127 * left, 127 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees + undershoot - SensorValue[gyro] < 0)
			{
				aDrive(127 * left, 127 * right);
			}
		}
	}
	else if (abs(error) < undershoot)
	{
		if (error > 0)
		{
			while (degrees - SensorValue[gyro] > 0)
			{
				aDrive(50 * left, 50 * right);
			}
		}
		else if (error < 0)
		{
			while (degrees - SensorValue[gyro] < 0)
			{
				aDrive(50 * left, 50 * right);
			}
		}
	}

	aDrive((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(250);
	aDrive(0,0);

	/*	if (degrees - SensorValue[gyro] > 50)
	{
	while (degrees - SensorValue[gyro] > 0)
	{
	aDrive(90 * left, 90 * right);
	}
	}
	else if (degrees - SensorValue[gyro] < -50)
	{
	while (degrees - SensorValue[gyro] < 0)
	{
	aDrive(90 * left, 90 * right);
	}
	}

	aDrive((127*left*-1)/9, (127*right*-1)/9);



	wait1Msec(50);
	aDrive(0,0);*/

	autonomousReady = true;
}



void gyroPIDControl(short goalPoint)
{
	autonomousReady = false;

	float pGain = (2.0/10.0);
	float iGain = (5.0/1000.0);
	float dGain = (70.0/1.0);

	goalPoint *= 10;
	goalPoint *= gyroMultiplier;

	int error = goalPoint - SensorValue[gyro];
	int newSpeed = 0;
	const int minSpeed = 26;
	int errorSum = 0;
	int errorDifference = 0;
	const int errorMargin = 20;

	while (abs(error) > errorMargin || abs(newSpeed) > minSpeed || time1[T4] < 100)
	{
		errorDifference = error - (goalPoint  - SensorValue[gyro] );
		error = goalPoint  - SensorValue[gyro] ;
		errorSum += error;

		if (abs(error) < errorMargin) errorSum = 0;

		if (errorSum * iGain > 100.0) errorSum = 100.0 / iGain;
		else if (errorSum * iGain < -100.0) errorSum = -100.0 / iGain;

		newSpeed = error * pGain + errorSum * iGain - errorDifference * dGain;

		if (newSpeed > -minSpeed && error < 0) newSpeed = -minSpeed;
		else if (newSpeed < minSpeed && error > 0) newSpeed = minSpeed;

		aDrive(newSpeed, newSpeed * (-1));
		if (abs(error) > errorMargin) clearTimer(T4);

		wait1Msec(1);

		//if (abs(SensorValue[gyro] - goalPoint) < 6 && abs(newSpeed) < 10) wait1Msec(100);
	}
	aDrive(0,0);

	autonomousReady = true;
}


void gyroRotate(int deg)
{
	autonomousReady = false;
	short goalPoint = (SensorValue[gyro] + deg * 10);
	while (goalPoint > 3600) goalPoint -= 3600;
	while (goalPoint < -3600) goalPoint += 3600;
	gyroFace(goalPoint);
}



void armPIDControl(short goalPoint, bool stopWhenMet)
{
	autonomousReady = false;

	checkArmLimitSwitch();

	float pGain = (3.0/1.0);
	float iGain = (1.0/1000.0);
	float dGain = (0.0/10.0);

	int errorSum = 0;
	int errorDifference = 0;
	int error = goalPoint - SensorValue[encoderArms];
	int newSpeed = 0;

	while (abs(error) > 5 || !stopWhenMet)
	{
		checkArmLimitSwitch();
		errorDifference = error - (goalPoint - SensorValue[encoderArms]);
		error = goalPoint - SensorValue[encoderArms];
		errorSum = errorSum + error;

		if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
		else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

		newSpeed = error * pGain + errorSum * iGain - errorDifference * dGain;
		aArms(newSpeed);
		wait1Msec(50);
	}

	autonomousReady = true;
}

void armPIDControl(short goalPoint)
{
	autonomousReady = false;
	armPIDControl(goalPoint, false);
}

task tClawPIDControl;

int tDrivePIDGoalPoint = 0;
short tClawPIDGoalPoint = openClawPotentiometerValue;
short tArmPIDGoalPoint = highCarryArmEncoderValue;
short tGyroPIDGoalPoint = 0;
bool waitForTClawPID = true;
bool waitForTArmPID = false;

bool isTDriveReady = true;
bool isTClawReady = true;
bool isTArmReady = true;
bool isTGyroFaceReady = true;
bool isTThrowReady = true;
bool isTGyroPIDReady = true;

void clawPIDControl(short goalPoint)
{
	autonomousReady = false;

	float pGain = (5.0/100.0);
	float iGain = (5.0/10000.0);
	float dGain = (1.0/10.0);

	int newSpeedClawLeft = 0;
	int newSpeedClawRight = 0;

	int errorSumClawLeft = 0;
	int errorSumClawRight = 0;
	int errorClawLeft = goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
	int errorClawRight = goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset);
	int errorDifferenceClawLeft = 0;
	int errorDifferenceClawRight = 0;

	int minSpeed = 15;

	while (abs(errorClawLeft) > 30 || abs(errorClawRight) > 30 || !waitForTClawPID)
	{
		errorDifferenceClawLeft = errorClawLeft - (goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset));
		errorDifferenceClawRight = errorClawRight - (goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset));

		errorClawLeft = goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
		errorClawRight = goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset);

		errorSumClawLeft += errorClawLeft;
		errorSumClawRight += errorClawRight;

		if (errorSumClawLeft * iGain > 127) errorSumClawLeft = 127.0 / iGain;
		else if (errorSumClawLeft * iGain < -127) errorSumClawLeft = -127.0 / iGain;

		if (errorSumClawRight * iGain > 127) errorSumClawRight  = 127.0 / iGain;
		else if (errorSumClawRight * iGain < -127) errorSumClawRight  = -127.0 / iGain;

		newSpeedClawLeft = errorClawLeft * pGain + errorSumClawLeft * iGain - errorDifferenceClawLeft * dGain;
		newSpeedClawRight = errorClawRight * pGain + errorSumClawRight * iGain - errorDifferenceClawRight * dGain;

		if (newSpeedClawLeft > -minSpeed && errorClawLeft < 0) newSpeedClawLeft = -minSpeed;
		else if (newSpeedClawLeft < minSpeed && errorClawLeft > 0) newSpeedClawLeft = minSpeed;

		if (newSpeedClawRight > -minSpeed && errorClawRight < 0) newSpeedClawRight = -minSpeed;
		else if (newSpeedClawRight < minSpeed && errorClawRight > 0) newSpeedClawRight = minSpeed;

		aClaw(newSpeedClawLeft, newSpeedClawRight);
		wait1Msec(10);
	}
	aClaw(0);

	autonomousReady = true;
}


task tDrivePIDControl()
{
	isTDriveReady = false;

	drivePIDControl(tDrivePIDGoalPoint);

	isTDriveReady = true;
}


task tGyroPIDControl()
{
	isTGyroPIDReady = false;

	gyroPIDControl(tGyroPIDGoalPoint);

	isTGyroPIDReady = true;
}

task tGyroFace()
{
	isTGyroFaceReady = false;

	gyroFace(tGyroPIDGoalPoint);

	isTGyroFaceReady = true;
}

task tClawPIDControl()
{
	isTClawReady = false;

	clawPIDControl(tClawPIDGoalPoint);

	isTClawReady = true;
}

task tArmPIDControl()
{
	isTArmReady = false;

	checkArmLimitSwitch();
	armPIDControl(tArmPIDGoalPoint, waitForTArmPID);

	isTArmReady = true;
}

task tKeepArmDown()
{
	while (true)
	{
		armPIDControl(0);
	}
}

void throw();

task tThrow()
{
	isTThrowReady = false;

	throw();

	isTThrowReady = true;
}

void startTKeepArmDown()
{
	stopTask(tKeepArmDown);
	stopTask(tArmPIDControl);
	startTask(tKeepArmDown);
}

void startTDrivePID(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tDrivePIDGoalPoint = goalPoint;
	startTask(tDrivePIDControl);
}

void startTArmPID(int goalPoint, bool stopWhenMet)
{
	stopTask(tArmPIDControl);
	stopTask(tKeepArmDown);
	stopTask(tThrow);
	tArmPIDGoalPoint = goalPoint;
	waitForTArmPID = stopWhenMet;

	startTask(tArmPIDControl);
}

void startTArmPID(int goalPoint)
{
	startTArmPID(goalPoint, false);
}

void startTClawPID(int goalPoint, bool waitForTClawPID)
{
	stopTask(tClawPIDControl);
	tClawPIDGoalPoint = goalPoint;
	waitForTClawPID = waitForTClawPID;
	startTask(tClawPIDControl);
}

void startTClawPID(int goalPoint)
{
	startTClawPID(goalPoint, false);
}


void startTGyroPID(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	startTask(tGyroPIDControl);
}

void startTGyroFace(int goalPoint)
{
	stopTask(tDrivePIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	tGyroPIDGoalPoint = goalPoint;
	startTask(tGyroFace);
}

void startTThrow()
{
	stopTask(tThrow);
	startTask(tThrow);
}


void waitForTDrive()
{
	wait1Msec(10);
	while (!isTDriveReady) { }
}

void waitForTArm()
{
	wait1Msec(10);
	while (!isTArmReady) { }
}

void waitForTClaw()
{
	wait1Msec(10);
	while (!isTClawReady) { }
}

void waitForTGyroFace()
{
	wait1Msec(10);
	while (!isTGyroFaceReady) { }
}

void waitForTGyroPID()
{
	wait1Msec(10);
	while (!isTGyroPIDReady) { }
}

void waitForTThrow()
{
	wait1Msec(10);
	while(!isTThrowReady) { }
}

void waitForAllPIDTasks()
{
	wait1Msec(10);
	while (!isTClawReady) { }
	while (!isTArmReady) { }
	while (!isTDriveReady) { }
	while (!isTGyroFaceReady) { }
	while (!isTGyroPIDReady) { }
	while (!isTThrowReady) { }
}

void stopAllTPID()
{
	stopTask(tClawPIDControl);
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tGyroPIDControl);
	stopTask(tGyroFace);
	stopTask(tThrow);
	stopTask(tKeepArmDown);
}


void throw()
{
	autonomousReady = false;

	checkArmLimitSwitch();
	stopTask(tArmPIDControl);
	stopTask(tClawPIDControl);
	stopTask(tKeepArmDown);
	if (SensorValue[encoderArms] < throwArmEncoderValue)
	{
		aArms(127);
		while (SensorValue[encoderArms] < clawReleaseArmEncoderValue) {	}
		aClaw(-127);
		while (SensorValue[encoderArms] < maxArmEncoderValue) { }
		aArms(0);
		aClaw(0);
	}

	autonomousReady = true;
}


void driveThrow()
{
	autonomousReady = false;

	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tClawPIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	stopTask(tKeepArmDown);
	checkArmLimitSwitch();
	aDrive(-127);
	aArms(127);
	while (SensorValue[encoderArms] < clawReleaseArmEncoderValue) {	}
	aClaw(-127);
	while (SensorValue[encoderArms] < maxArmEncoderValue) { }
	aArms(0);
	aDrive(0);
	aClaw(0);

	autonomousReady = true;
}

void driveThrow(int time)
{
	autonomousReady = false;

	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tClawPIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	stopTask(tKeepArmDown);
	checkArmLimitSwitch();
	aDrive(-127);
	aArms(127);
	while (SensorValue[encoderArms] < clawReleaseArmEncoderValue) {	}
	aClaw(-127);
	while (SensorValue[encoderArms] < maxArmEncoderValue) { }
	aArms(0);
	aDrive(0);
	aClaw(0);

	autonomousReady = true;
}

void grab(int time)
{
	autonomousReady = false;

	stopTask(tClawPIDControl);

	aClaw(127);
	wait1Msec(time);
	aClaw(60);

	autonomousReady = true;
}

void grab()
{
	grab(700);
}


task autonomous()
{
	if (isLCDEnabled)
	{
		if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);
		displayLCDCenteredString(0, "Balsdeep-_-Singh");
		displayLCDCenteredString(1, getProgramName(selectedProgram));
	}

	if (selectedProgram == LCDScreenAutonomousS || selectedProgram == LCDScreenAutonomousSWC)
	{
	}

	if (!isCompetitionMode)
	{
		selectedProgram = LCDScreenUserControl;
		startTask(usercontrol);
	}
}


task PIDMode()
{
/*
	float pGain = (127.0/900.0);
	float iGain = (8.0/1000.0);
	int pidRefreshRate = 30;

	while (true)
	{
		if (isJoystickLCDMode()){ }
		else if (vexRT[Btn8U] == 1)
		{
			pGain = pGain + (1.0/1000.0);
			wait1Msec(100);
		}
		else if (vexRT[Btn8D] == 1)
		{
			pGain = + pGain - (1.0/1000.0);
			wait1Msec(100);
		}
		else if (vexRT[Btn7U] == 1)
		{
			iGain = iGain + (1.0/1000.0);
			wait1Msec(100);
		}
		else if (vexRT[Btn7D] == 1)
		{
			iGain = iGain - (1.0/1000.0);
			wait1Msec(100);
		}
		else if (vexRT[Btn6U] == 1)
		{
			pidRefreshRate += 1;
			wait1Msec(500);
		}
		else if (vexRT[Btn5U] == 1)
		{
			pidRefreshRate -= 1;
			wait1Msec(500);
		}
		else if (vexRT[Btn7R] == 1)
		{
			if (motor[motorClawLeft] == 0)
			{
				motor[motorClawLeft] = 75;
				motor[motorClawRight] = 75;
				while (vexRT[Btn7R] == 1) { }

		}
			else
			{
				motor[motorClawLeft] = 0;
				motor[motorClawRight] = 0;
				while (vexRT[Btn7R] == 1) { }
			}
		}// 0.099 pgain 0.002 igain 26 pid refresh rate
		else if (vexRT[Btn8R] == 1)
		{

			short goalPoint = 900;
			while (goalPoint > 3600) goalPoint -= 3600;
			while (goalPoint < -3600) goalPoint += 3600;
			int error = 0;

			error = SensorValue[gyro] - goalPoint;
			float newSpeed = 0;
			int minSpeed = 25;
			int errorSum = 0;

			while (abs(error) > 3 && vexRT[Btn8R] == 1)
			{
				errorSum += error;
				error = SensorValue[gyro] - goalPoint;
				newSpeed = error * pGain + errorSum * iGain;

				if (newSpeed < minSpeed && newSpeed > -1) newSpeed = minSpeed;
				else if (newSpeed > -minSpeed && newSpeed < 1) newSpeed = -minSpeed;
				aDrive(newSpeed * (-1), newSpeed);
				//string debugLine = "";
				//debugLine = sprintf(debugLine, "%20.0d%c", count);
				//writeDebugStreamLine(debugLine);

				wait1Msec(pidRefreshRate);
			}
			aDrive(0,0);

		}
		else if (vexRT[Btn8L] == 1)
		{
			while (vexRT[Btn8L] == 1)
			{
				aDrive(127, -127);
			}
			aDrive(0,0);
		}
	}*/
}


/*---------------------------------------------------------------------------*/
/*																																					 */
/*															User Control Task														 */
/*																																					 */
/*	This task is used to control your robot during the user control phase of */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/


bool lockControls = true;
bool areControlsOverriden = false;

int checkSlewRate(int lastSpeed, int newSpeed)
{
	int speedDifference = lastSpeed - newSpeed;
	if (speedDifference < 20 || speedDifference > -20)
	{
		return newSpeed;
	}
	else
	{
		return newSpeed * 0.3;
	}
}


task arms()
{

	float pGain = (5.0/10.0);
	float iGain = (1.0/10000.0);
	float dGain = (0.0/10.0);

	while (true)
	{
		checkArmLimitSwitch();
		if (!lockControls && !isJoystickLCDMode())
		{
			if ((vexRT[joyArms] > armsJoystickDeadzone || vexRT[joyArms] < -armsJoystickDeadzone) && ( (SensorValue[encoderArms] < 1220 && !areControlsOverriden) || areControlsOverriden)  )
			{
				while ((vexRT[joyArms] > armsJoystickDeadzone || vexRT[joyArms] < -armsJoystickDeadzone) && ( (SensorValue[encoderArms] < 1220 && !areControlsOverriden) || areControlsOverriden)  )
				{
					checkArmLimitSwitch();
					aArms(vexRT[joyArms]);
				}
				aArms(0);
			}
			else if (SensorValue[encoderArms] > 1220 && vexRT[joyArms] > -armsJoystickDeadzone && !areControlsOverriden)
			{
				int errorSum = 0;
				short goalPoint = 1100;
				int error = goalPoint - SensorValue[encoderArms];
				int errorDifference = 0;
				int lastMotorPower = 0;
				int newPower = 0;

				while (vexRT[joyArms] > -armsJoystickDeadzone && !areControlsOverriden)
				{
					errorDifference = error - (goalPoint - SensorValue[encoderArms]);
					error = goalPoint - SensorValue[encoderArms];
					errorSum = errorSum + error;
					lastMotorPower = newPower;

					if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
					else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

					newPower = error * pGain + errorSum * iGain - dGain * errorDifference;
					aArms(newPower);
					wait1Msec(50);
				}
			}
			else if (vexRT[btnBlock] == 1)
			{
				int errorSum = 0;
				short goalPoint = blockEncoderValue;
				int error = goalPoint - SensorValue[encoderArms];
				int errorDifference = 0;
				int lastMotorPower = 0;
				int newPower = 0;

				while (vexRT[Btn7L] == 0 && vexRT[btnArmsManualRaise] == 0 && vexRT[joyArms] < armsJoystickDeadzone && vexRT[joyArms] > -armsJoystickDeadzone)
				{
					errorDifference = error - (goalPoint - SensorValue[encoderArms]);
					error = goalPoint - SensorValue[encoderArms];
					errorSum = errorSum + error;
					lastMotorPower = newPower;

					if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
					else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

					newPower = error * pGain + errorSum * iGain - dGain * errorDifference;
					aArms(newPower);
					wait1Msec(50);
				}
			}
			else if (SensorValue[encoderArms] < 100 && !areControlsOverriden)
			{
				checkArmLimitSwitch();
				int errorSum = 0;
				short goalPoint = 0;
				int error = goalPoint - SensorValue[encoderArms];
				int errorDifference = 0;
				int lastMotorPower = 0;
				int newPower = 0;

				while (vexRT[Btn7L] == 0 && vexRT[btnArmsManualRaise] == 0 && vexRT[btnBlock] == 0 && vexRT[joyArms] < armsJoystickDeadzone && vexRT[joyArms] > -armsJoystickDeadzone)
				{
					checkArmLimitSwitch();
					errorDifference = error - (goalPoint - SensorValue[encoderArms]);
					error = goalPoint - SensorValue[encoderArms];
					errorSum = errorSum + error;
					lastMotorPower = newPower;

					if (errorSum * iGain > 127) errorSum = 127.0 / iGain;
					else if (errorSum * iGain < -127) errorSum = -127.0 / iGain;

					newPower = error * pGain + errorSum * iGain - dGain * errorDifference;
					aArms(newPower);
					wait1Msec(50);
				}
			}
			else if (vexRT[btnResetArmSensor] == 1)
			{
				SensorValue[encoderArms] = 0;
			}
		}
	}
}

short axisX;
short axisY;
task drive()
{
	bool isDriveOverriden = false;

	/*while (true)
	{
	if (vexRT[Btn7U] == 1) {
	aDrive(127,127);

	}else aDrive(0);
	}*/
	float a = (0.00022419);
	float ax = (0.000053321);
	float b = (-0.0012715);
	float h = (-48.851);
	float c = (20.509);
	short x = 0, y = 0;

	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[joyDriveX] > driveJoystickDeadzone || vexRT[joyDriveX] < -driveJoystickDeadzone || vexRT[joyDriveY] > driveJoystickDeadzone || vexRT[joyDriveY] < -driveJoystickDeadzone)
			{
				x = vexRT[Ch2];
				y = vexRT[Ch1];
				axisY = a * pow(vexRT[Ch2] - (h * (vexRT[Ch2] / (-abs(vexRT[Ch2] + 0.1)))), 3) + (20 * (vexRT[Ch2] / (abs(vexRT[Ch2] + 0.1))));
				axisX = ax * pow(vexRT[Ch1] - (2 * (vexRT[Ch1] / (-abs(vexRT[Ch1] + 0.1)))), 3) + (20 * (vexRT[Ch1] / (abs(vexRT[Ch1] + 0.1))));

				if (!isDriveOverriden) aDrive(axisY + axisX, axisY - axisX);
				else aDrive(-axisX, axisX);
			}
			else if (vexRT[btnSensitiveDrive] == 1)
			{
				while (vexRT[btnSensitiveDrive] == 1) { }
				isDriveOverriden = !isDriveOverriden;
				if (isDriveOverriden)
				{
					//		a = 0;
					ax = (0.000011219);
				}
				else
				{
					//	a = (0.00022419);
					ax = (0.000053321);
				}
				//while (vexRT[btnSensitiveDrive] == 0)
				//{
				//	aDrive( (vexRT[Ch2] - vexRT[Ch1]) * 0.4), (vexRT[Ch1] + vexRT[Ch2]) * 0.4);
				//}
			}
			else aDrive(0,0);
		}
		wait1Msec(25);
	}
}


void userClawPIDControl(int goalPoint, TVexJoysticks btn)
{
	float pGain = (1.0/10.0);
	float iGain = (1.0/10000.0);
	float dGain = (0.0/1000.0);

	float newSpeedClawLeft = 0;
	float newSpeedClawRight = 0;

	int errorSumClawLeft = 0;
	int errorSumClawRight = 0;

	int errorClawLeft = goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
	int errorClawRight = goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset);

	int errorDifferenceClawLeft = 0;
	int errorDifferenceClawRight = 0;

	while (!areControlsOverriden)
	{
		errorDifferenceClawLeft = errorClawLeft - (goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset));
		errorDifferenceClawRight = errorClawRight - (goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset));

		errorClawLeft = goalPoint - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset);
		errorClawRight = goalPoint - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset);

		errorSumClawLeft += errorClawLeft;
		errorSumClawRight += errorClawRight;

		if (abs(errorClawLeft) > 1 || abs(errorClawRight) < 1)
		{
			newSpeedClawLeft = errorClawLeft * pGain + errorSumClawLeft * iGain - errorDifferenceClawLeft * dGain;
			newSpeedClawRight = errorClawRight * pGain + errorSumClawRight * iGain - errorDifferenceClawRight * dGain;
		}
		else
		{
			newSpeedClawLeft = 0;
			newSpeedClawRight = 0;
		}

		if 	( (btn == btnClawHalfway && (vexRT[btnClawManualOpen] == 1 || vexRT[btnClawGrab] == 1 || vexRT[btnClawOverride] == 1 || vexRT[btnBlock] == 1) )
			|| (btn == btnClawManualOpen && (vexRT[btnClawHalfway] == 1 || vexRT[btnClawGrab] == 1 || vexRT[btnClawOverride] == 1 || vexRT[btnBlock] == 1) )
		|| (btn == btnBlock && (vexRT[btnClawHalfway] == 1 || vexRT[btnClawGrab] == 1 || vexRT[btnClawOverride] == 1 || vexRT[btnClawManualOpen] == 1) ))
		break;

		aClaw(newSpeedClawLeft, newSpeedClawRight);
		wait1Msec(10);
	}
	aClaw(0);
}


task claw()
{
	float pGain = (5.0/10.0);
	while (true)
	{
		if (!lockControls && !isJoystickLCDMode())
		{
			if (vexRT[btnClawOverride] == 1)
			{
				areControlsOverriden = !areControlsOverriden;
				while (vexRT[btnClawOverride] == 1) { }
			}
			else if (!areControlsOverriden)
			{
				if (vexRT[btnClawGrab] == 1)
				{
					while (vexRT[btnClawHalfway] == 0 && vexRT[btnClawManualOpen] == 0 && vexRT[btnClawOverride] == 0 && vexRT[btnBlock] == 0)
					{
						//	aClawLeft( (closedClawPotentiometerValue - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset)) * pGain);
						//	aClawRight((closedClawPotentiometerValue - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset)) * pGain);

						if ((SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) < closedClawPotentiometerValue)
							aClawLeft(300 - (SensorValue[potentiometerClawLeft] + potentiometerClawLeftOffset) / 10);
						else aClawLeft(11);

						if ((SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) < closedClawPotentiometerValue)
							aClawRight(300 - (SensorValue[potentiometerClawRight] + potentiometerClawRightOffset) / 10);
						else aClawRight(11);

					}

				}
				else if (vexRT[btnClawHalfway] == 1)
				{
					userClawPIDControl(halfwayClawPotentiometerValue, btnClawHalfway);
				}
				else if (vexRT[btnClawManualOpen] == 1)
				{
					userClawPIDControl(openClawPotentiometerValue, btnClawManualOpen);
				}
				else if (vexRT[btnBlock] == 1)
				{
					userClawPIDControl(openClawPotentiometerValue, btnBlock);
				}
			}
			else if (areControlsOverriden)
			{
				if (vexRT[joyClaw] > clawJoystickDeadzone || vexRT[joyClaw] < -clawJoystickDeadzone)
				{
					while (vexRT[joyClaw] > clawJoystickDeadzone || vexRT[joyClaw] < -clawJoystickDeadzone)
					{
						aClaw(vexRT[joyClaw]);
					}
					aClaw(0);
				}
				else if (vexRT[btnClawGrab] == 1)
				{
					aClaw(90);
					while (vexRT[btnClawGrab] == 1) { }
					aClaw(-90);
					clearTimer(T1);
					while (time1[T1] < 600 && vexRT[btnClawGrab] == 0 && vexRT[btnClawManualOpen] == 1 && vexRT[joyClaw] < clawJoystickDeadzone && vexRT[joyClaw] > -clawJoystickDeadzone) { }
					aClaw(0);
				}
				else if (vexRT[btnClawManualOpen] == 1)
				{
					aClaw(-90);
					clearTimer(T1);
					while (time1[T1] < 600 && vexRT[btnClawGrab] == 0 && vexRT[btnClawManualOpen] == 1 && vexRT[joyClaw] < clawJoystickDeadzone && vexRT[joyClaw] > -clawJoystickDeadzone) { }
					aClaw(0);
				}
			}
		}
	}
}


task controlLock()
{
	while (true)
	{
		if (vexRT[btnControlLock1] == 1 && vexRT[btnControlLock2] == 1 && lockControls)
		{
			while (vexRT[btnControlLock1] == 1 && vexRT[btnControlLock2] == 1) wait1Msec(10);
			lockControls = false;
		}
		else if (vexRT[btnControlLock1] == 1 && vexRT[btnControlLock2] == 1 && !lockControls)
		{
			while (vexRT[btnControlLock1] == 1 && vexRT[btnControlLock2] == 1) wait1Msec(10);
			lockControls = true;
		}
	}
}


task usercontrol()
{
	if (isArmsEnabled) startTask(arms);
	if (isDriveEnabled) startTask(drive);
	if (isClawEnabled) startTask(claw);
	if (isControlLockEnabled) startTask(controlLock);
	else lockControls = false;
	if (getTaskState(loadLCDScreen) == taskStateStopped) startTask(loadLCDScreen);

	if (isLCDEnabled)
	{
		displayLCDCenteredString(0, "Balsdeep-_-Singh");
		displayLCDCenteredString(1, "User Control");
	}
}


void startUp()
{
	stopTasks();
	allMotorsOff();
	string programName = getProgramName(selectedProgram);

	if (isSideDependent(selectedProgram))
	{
		if (autonomousSide == sideLeft) programName += "L";
		else if (autonomousSide == sideRight) programName += "R";
	}

	if (selectedProgram == LCDScreenUserControl) startTask(usercontrol);
	else if (selectedProgram == LCDScreenPIDMode) startTask(PIDMode);
	else if (selectedProgram > 200 && selectedProgram < 300)
	{
		displayLCDCenteredString(0, programName);
		clearLCDLine(1);
		displayLCDString(1, 2, "Starts In 3");
		wait1Msec(1000);
		displayLCDString(1, 12, "2");
		wait1Msec(1000);
		displayLCDString(1, 12, "1");
		wait1Msec(1000);

		startTask(autonomous);
	}
}

void stopTasks()
{
	stopTask(autonomous);
	stopTask(arms);
	stopTask(drive);
	stopTask(claw);
	stopTask(controlLock);
	stopTask(usercontrol);
	stopTask(PIDMode);
	stopTask(tDrivePIDControl);
	stopTask(tArmPIDControl);
	stopTask(tClawPIDControl);
	stopTask(tGyroFace);
	stopTask(tGyroPIDControl);
	stopTask(tKeepArmDown);
	stopTask(tThrow);
}
